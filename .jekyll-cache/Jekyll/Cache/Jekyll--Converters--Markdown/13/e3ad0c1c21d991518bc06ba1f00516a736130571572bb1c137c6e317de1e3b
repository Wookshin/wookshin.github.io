I"<p><br /></p>

<h1 id="this">this</h1>

<p><br /></p>

<h2 id="1-this-키워드">1. this 키워드</h2>

<p>객체는 상태(state)를 나타내는 프로퍼티와 동작(behavior)을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조입니다.</p>

<p>동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 합니다.<br />
이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 <strong>자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 합니다.</strong></p>

<p>객체 리터럴 방식으로 생성한 객체의 경우 메서드 내부에서 메서드 자신이 속한 객체를 가리키는 식별자를 재귀적으로 참조할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// 프로퍼티: 객체 고유의 상태 데이터</span>
  <span class="na">radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="c1">// 메서드: 상태 데이터를 참조하고 조작하는 동작</span>
  <span class="nx">getDiameter</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면</span>
    <span class="c1">// 자신이 속한 객체인 circle을 참조할 수 있어야 한다.</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">getDiameter</code> 메서드 내에서 메서드 자신이 속한 객체를 가리키는 식별자 <code class="language-html highlighter-rouge">circle</code>을 참조하고 있습니다.<br />
이 참조 표현식이 평가되는 시점은 <code class="language-html highlighter-rouge">getDiameter</code> 메서드가 호출되어 함수 몸체가 실행되는 시점입니다.</p>

<p>위 예제의 객체 리터럴은 <code class="language-html highlighter-rouge">circle</code> 변수에 할당되기 직전에 평가됩니다.<br />
따라서 <code class="language-html highlighter-rouge">getDiameter</code> 메서드가 호출되는 시점에는 이미 객체 리터럴의 평가가 완료되어 객체가 생성되었고 <code class="language-html highlighter-rouge">circle</code> 식별자에 생성된 객체가 할당된 이후입니다.<br />
따라서 메서드 내부에서 <code class="language-html highlighter-rouge">circle</code> 식별자를 참조할 수 있습니다.</p>

<p>하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않습니다.<br />
생성자 함수 방식으로 인스턴스를 생성하는 경우를 생각해봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span>
  <span class="p">????.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getDiameter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">????.</span><span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.</span>
<span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수 내부에서는 프로퍼티 또는 메서드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 합니다.<br />
하지만 생성자 함수에 의한 객체 생성 방식은 먼저 생성자 함수를 정의한 이후 <code class="language-html highlighter-rouge">new</code> 연산자와 함께 생성자 함수를 호출하는 단계가 추가로 필요합니다.<br />
다시 말해, 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 합니다.</p>

<p>생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없습니다.<br />
따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요합니다.<br />
이를 위해 자바스크립트는 <code class="language-html highlighter-rouge">this</code>라는 특수한 식별자를 제공합니다.</p>

<p><strong><code class="language-html highlighter-rouge">this</code>는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)입니다.</strong><br />
<strong><code class="language-html highlighter-rouge">this</code>를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다.</strong></p>

<p><code class="language-html highlighter-rouge">this</code>는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있습니다.<br />
함수를 호출하면 <code class="language-html highlighter-rouge">arguments</code> 객체와 <code class="language-html highlighter-rouge">this</code>가 암묵적으로 함수 내부에 전달됩니다.<br />
함수 내부에서 <code class="language-html highlighter-rouge">arguments</code> 객체를 지역 변수처럼 사용할 수 있는 것처럼 <code class="language-html highlighter-rouge">this</code>도 지역 변수처럼 사용할 수 있습니다.<br />
단, <strong><code class="language-html highlighter-rouge">this</code>가 가리키는 값, 즉 <code class="language-html highlighter-rouge">this</code> 바인딩은 함수 호출 방식에 의해 동적으로 결정됩니다.</strong></p>

<p><br /></p>

<blockquote>
  <p><strong><code class="language-html highlighter-rouge">this</code> 바인딩(this binding)</strong><br />
바인딩이란 식별자와 값을 연결하는 과정을 의미합니다.<br />
예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것입니다.<br />
<code class="language-html highlighter-rouge">this</code> 바인딩은 <code class="language-html highlighter-rouge">this</code>(키워드로 분류되지만 식별자 역할을 합니다)와 <code class="language-html highlighter-rouge">this</code>가 가리킬 객체를 바인딩하는 것입니다.</p>
</blockquote>

<p><br /></p>

<p>위에서 살펴본 객체 리터럴과 생성자 함수의 예제를 <code class="language-html highlighter-rouge">this</code>를 사용해 수정해 봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 객체 리터럴</span>
<span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="nx">getDiameter</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this는 메서드를 호출한 객체를 가리킨다.</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p><br /></p>

<p>객체 리터럴의 메서드 내부에서의 <code class="language-html highlighter-rouge">this</code>는 메서드를 호출한 객체, 즉 <code class="language-html highlighter-rouge">circle</code>을 가리킵니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getDiameter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 인스턴스 생성</span>
<span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수 내부의 <code class="language-html highlighter-rouge">this</code>는 생성자 함수가 생성할 인스턴스를 가리킵니다.<br />
이처럼 <code class="language-html highlighter-rouge">this</code>는 상황에 따라 가리키는 대상이 다릅니다.</p>

<p>자바나 C++ 같은 클래스 기반 언어에서 <code class="language-html highlighter-rouge">this</code>는 언제나 클래스가 생성하는 인스턴스를 가리킵니다.<br />
하지만 <strong>자바스크립트의 <code class="language-html highlighter-rouge">this</code>는 함수가 호출되는 방식에 따라 <code class="language-html highlighter-rouge">this</code>에 바인딩될 값, 즉 <code class="language-html highlighter-rouge">this</code> 바인딩이 동적으로 결정됩니다.</strong><br />
또한 strict mode(엄격 모드) 역시 <code class="language-html highlighter-rouge">this</code> 바인딩에 영향을 줍니다.</p>

<p><code class="language-html highlighter-rouge">this</code> 코드 어디에서든 참조 가능합니다.<br />
전역에서도 함수 내부에서도 참조할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// this는 어디서든지 참조 가능하다.</span>
<span class="c1">// 전역에서 this는 전역 객체 window를 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>

<span class="kd">function</span> <span class="nx">square</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
  <span class="k">return</span> <span class="nx">number</span> <span class="o">*</span> <span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">square</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// {name: "Lee", getName: ƒ}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// Lee</span>

<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="c1">// 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Person {name: "Lee"}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>하지만 <code class="language-html highlighter-rouge">this</code>는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있습니다.</strong><br />
따라서 strict mode가 적용된 일반 함수 내부의 <code class="language-html highlighter-rouge">this</code>에는 <code class="language-html highlighter-rouge">undefined</code>가 바인딩됩니다.<br />
일반 함수 내부에서 <code class="language-html highlighter-rouge">this</code>를 사용할 필요가 없기 때문입니다.</p>

<p><br /><br /></p>

<h2 id="2-함수-호출-방식과-this-바인딩">2. 함수 호출 방식과 this 바인딩</h2>

<p><strong><code class="language-html highlighter-rouge">this</code> 바인딩(<code class="language-html highlighter-rouge">this</code>에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정됩니다.</strong></p>

<p><br /></p>

<blockquote>
  <p><strong>렉시컬 스코프와 <code class="language-html highlighter-rouge">this</code> 바인딩은 결정 시기가 다릅니다.</strong><br />
함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(lexical scope)는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정합니다.<br />
하지만 <code class="language-html highlighter-rouge">this</code> 바인딩은 함수 호출 시점에 결정됩니다.</p>
</blockquote>

<p><br /></p>

<p>주의할 것은 동일한 함수도 다양한 방식으로 호출할 수 있다는 것입니다.<br />
함수를 호출하는 방식은 다음과 같이 다양합니다.</p>

<ol>
  <li>일반 함수 호출</li>
  <li>메서드 호출</li>
  <li>생성자 함수 호출</li>
  <li>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</li>
</ol>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 동일한 함수도 다양한 방식으로 호출할 수 있다.</span>

<span class="c1">// 1. 일반 함수 호출</span>
<span class="c1">// foo 함수를 일반적인 방식으로 호출</span>
<span class="c1">// foo 함수 내부의 this는 전역 객체 window를 가리킨다.</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// window</span>

<span class="c1">// 2. 메서드 호출</span>
<span class="c1">// foo 함수를 프로퍼티 값으로 할당하여 호출</span>
<span class="c1">// foo 함수 내부의 this는 메서드를 호출한 객체 obj를 가리킨다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// obj</span>

<span class="c1">// 3. 생성자 함수 호출</span>
<span class="c1">// foo 함수를 new 연산자와 함께 생성자 함수로 호출</span>
<span class="c1">// foo 함수 내부의 this는 생성자 함수가 생성한 인스턴스를 가리킨다.</span>
<span class="k">new</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// foo {}</span>

<span class="c1">// 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출</span>
<span class="c1">// foo 함수 내부의 this는 인수에 의해 결정된다.</span>
<span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span> <span class="p">};</span>

<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// bar</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// bar</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">bar</span><span class="p">)();</span> <span class="c1">// bar</span>
</code></pre></div></div>

<p><br /></p>

<p>함수 호출 방식에 따라 <code class="language-html highlighter-rouge">this</code> 바인딩이 어떻게 결정되는지 알아봅시다.</p>

<p><br /></p>

<h3 id="21-일반-함수-호출">2.1 일반 함수 호출</h3>

<p><strong>기본적으로 <code class="language-html highlighter-rouge">this</code>에는 전역 객체(global object)가 바인딩됩니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
  <span class="p">}</span>
  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제처럼 전역 함수는 물론이고 중첩 함수를 <strong>일반 함수로 호출하면 함수 내부의 <code class="language-html highlighter-rouge">this</code>에는 전역 객체가 바인딩됩니다.</strong><br />
다만 <code class="language-html highlighter-rouge">this</code>는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 <code class="language-html highlighter-rouge">this</code>는 의미가 없습니다.<br />
따라서 다음 예제처럼 strict mode가 적용된 일반 함수 내부의 <code class="language-html highlighter-rouge">this</code>에는 <code class="language-html highlighter-rouge">undefined</code>가 바인딩됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// undefined</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// undefined</span>
  <span class="p">}</span>
  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<p>메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 <code class="language-html highlighter-rouge">this</code>에는 전역 객체가 바인딩됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.</span>
<span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.</span>
<span class="c1">// const value = 1;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// {value: 100, foo: ƒ}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 100</span>

    <span class="c1">// 메서드 내에서 정의한 중첩 함수</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="p">}</span>

    <span class="c1">// 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.</span>
    <span class="nx">bar</span><span class="p">();</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<p>콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code>에도 전역 객체가 바인딩됩니다.<br />
어떠한 함수라도 일반 함수로 호출되면 <code class="language-html highlighter-rouge">this</code>에 전역 객체가 바인딩됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// {value: 100, foo: ƒ}</span>
    <span class="c1">// 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">callback's this: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// window</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">callback's this.value: </span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p><strong><code class="language-html highlighter-rouge">setTimeout</code> 함수</strong><br />
<code class="language-html highlighter-rouge">setTimeout</code> 함수는 두 번째 인수로 전달한 시간(ms)만큼 대기한 다음, 첫 번째 인수로 전달한 콜백 함수를 호출하는 타이머 함수입니다.<br />
위 예제에서는 100ms를 대기한 다음, 콜백 함수를 호출합니다.</p>
</blockquote>

<p><br /></p>

<p><strong>이처럼 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 <code class="language-html highlighter-rouge">this</code>에는 전역 객체가 바인딩됩니다.</strong></p>

<p>하지만 메서드 내에서 정의한 중첩 함수 또는 메서드에게 전달한 콜백 함수(보조 함수)가 일반 함수로 호출될 때 메서드 내의 중첩 함수 또는 콜백 함수의 <code class="language-html highlighter-rouge">this</code>가 전역 객체를 바인딩하는 것은 문제가 있습니다.<br />
중첩 함수 또는 콜백 함수는 외부 함수를 돕는 핼퍼 함수의 역할을 하므로 외부 함수의 일부 로직을 대신하는 경우가 대부분입니다.<br />
하지만 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 <code class="language-html highlighter-rouge">this</code>가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 핼퍼 함수로 동작하기 어렵게 만듭니다.</p>

<p>위 예제의 경우 메서드 내부에서 <code class="language-html highlighter-rouge">setTimeout</code> 함수에 전달된 콜백 함수의 <code class="language-html highlighter-rouge">this</code>에는 전역 객체가 바인딩됩니다.<br />
따라서 <code class="language-html highlighter-rouge">this.value</code>는 <code class="language-html highlighter-rouge">obj</code> 객체의 <code class="language-html highlighter-rouge">value</code> 프로퍼티가 아닌 전역 객체의 <code class="language-html highlighter-rouge">value</code> 프로퍼티, 즉 <code class="language-html highlighter-rouge">window.value</code>를 참조합니다.<br />
<code class="language-html highlighter-rouge">var</code> 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되므로 <code class="language-html highlighter-rouge">window.value</code>는 <code class="language-html highlighter-rouge">1</code> 입니다.</p>

<p>메서드 내부의 중첩 함수나 콜백 함수의 <code class="language-html highlighter-rouge">this</code> 바인딩을 메서드의 <code class="language-html highlighter-rouge">this</code> 바인딩과 일치시키기 위한 방법은 다음과 같습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this 바인딩(obj)을 변수 that에 할당한다.</span>
    <span class="kd">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="c1">// 콜백 함수 내부에서 this 대신 that을 참조한다.</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 100</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<p>위 방법 이외에도 자바스크립트는 <code class="language-html highlighter-rouge">this</code>를 명시적으로 바인딩할 수 있는 <code class="language-html highlighter-rouge">Function.prototype.apply</code>, <code class="language-html highlighter-rouge">Function.prototype.call</code>, <code class="language-html highlighter-rouge">Function.prototype.bind</code> 메서드를 제공합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 콜백 함수에 명시적으로 this를 바인딩한다.</span>
    <span class="nx">setTimeout</span><span class="p">(</span>
      <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 100</span>
      <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
      <span class="mi">100</span>
    <span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<p>또는 화살표 함수를 사용해서 <code class="language-html highlighter-rouge">this</code> 바인딩을 일치시킬 수도 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 100</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="22-메서드-호출">2.2 메서드 호출</h3>

<p>메서드 내부의 <code class="language-html highlighter-rouge">this</code>에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩됩니다.<br />
주의할 것은 메서드 내부의 <code class="language-html highlighter-rouge">this</code>는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 메서드 getName을 호출한 객체는 person이다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제의 <code class="language-html highlighter-rouge">getName</code> 메서드는 <code class="language-html highlighter-rouge">person</code> 객체의 메서드로 정의되었습니다.<br />
메서드는 프로퍼티에 바인딩된 함수입니다.<br />
즉, <code class="language-html highlighter-rouge">person</code> 객체의 <code class="language-html highlighter-rouge">getName</code> 프로퍼티가 가리키는 함수 객체는 <code class="language-html highlighter-rouge">person</code> 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체입니다.<br />
<code class="language-html highlighter-rouge">getName</code> 프로퍼티가 함수 객체를 가리키고 있을 뿐입니다.</p>

<p>따라서 <code class="language-html highlighter-rouge">getName</code> 프로퍼티가 가리키는 함수 객체, 즉 <code class="language-html highlighter-rouge">getName</code> 메서드는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">// getName 메서드를 anotherPerson 객체의 메서드로 할당</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="c1">// getName 메서드를 호출한 객체는 anotherPerson이다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// Kim</span>

<span class="c1">// getName 메서드를 변수에 할당</span>
<span class="kd">const</span> <span class="nx">getName</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="c1">// getName 메서드를 일반 함수로 호출</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// ''</span>
<span class="c1">// 일반 함수로 호출된 getName 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.</span>
<span class="c1">// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.</span>
<span class="c1">// Node.js 환경에서 this.name은 undefined다.</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 메서드 내부의 <code class="language-html highlighter-rouge">this</code>는 프로퍼티로 메서드를 가리키고 있는 객체와는 관계가 없고 메서드를 호출한 객체에 바인딩됩니다.</p>

<p>프로토타입 메서드 내부에서 사용된 <code class="language-html highlighter-rouge">this</code>도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// getName 메서드를 호출한 객체는 me다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// ① Lee</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// getName 메서드를 호출한 객체는 Person.prototype이다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// ② Kim</span>
</code></pre></div></div>

<p><br /></p>

<p>①의 경우 <code class="language-html highlighter-rouge">getName</code> 메서드를 호출한 객체는 <code class="language-html highlighter-rouge">me</code>입니다.<br />
따라서 <code class="language-html highlighter-rouge">getName</code> 메서드 내부의 <code class="language-html highlighter-rouge">this</code>는 <code class="language-html highlighter-rouge">me</code>를 가리키며 <code class="language-html highlighter-rouge">this.name</code>은 <code class="language-html highlighter-rouge">'Lee'</code>입니다.</p>

<p>②의 경우 <code class="language-html highlighter-rouge">getName</code> 메서드를 호출한 객체는 <code class="language-html highlighter-rouge">Person.prototype</code>입니다.<br />
<code class="language-html highlighter-rouge">Person.prototype</code>도 객체이므로 직접 메서드를 호출할 수 있습니다.<br />
따라서 <code class="language-html highlighter-rouge">getName</code> 메서드 내부의 <code class="language-html highlighter-rouge">this</code>는 <code class="language-html highlighter-rouge">Person.prototype</code>을 가리키며 <code class="language-html highlighter-rouge">this.name</code>은 <code class="language-html highlighter-rouge">'Kim'</code>입니다.</p>

<p><br /></p>

<h3 id="23-생성자-함수-호출">2.3 생성자 함수 호출</h3>

<p>생성자 함수 내부의 <code class="language-html highlighter-rouge">this</code>에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">getDiameter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 반지름이 5인 Circle 객체를 생성</span>
<span class="kd">const</span> <span class="nx">circle1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// 반지름이 10인 Circle 객체를 생성</span>
<span class="kd">const</span> <span class="nx">circle2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle1</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle2</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 20</span>
</code></pre></div></div>

<p><br /></p>

<p>생서자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수입니다.<br />
일반 함수와 동일한 방법으로 생성자 함수를 정의하고 <code class="language-html highlighter-rouge">new</code> 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작합니다.<br />
만약 <code class="language-html highlighter-rouge">new</code> 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다. 즉, 일반적인 함수의 호출이다.</span>
<span class="kd">const</span> <span class="nx">circle3</span> <span class="o">=</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>

<span class="c1">// 일반 함수로 호출된 Circle에는 반환문이 없으므로 암묵적으로 undefined를 반환한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle3</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="c1">// 일반 함수로 호출된 Circle 내부의 this는 전역 객체를 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">radius</span><span class="p">);</span> <span class="c1">// 15</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="24-functionprototypeapplycallbind-메서드에-의한-간접-호출0">2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출0</h3>

<p><code class="language-html highlighter-rouge">apply</code>, <code class="language-html highlighter-rouge">call</code>, <code class="language-html highlighter-rouge">bind</code> 메서드는 <code class="language-html highlighter-rouge">Function.prototype</code>의 메서드입니다.<br />
즉, 이들 메서드는 모든 함수가 상속받아 사용할 수 있습니다.</p>

<p><code class="language-html highlighter-rouge">Function.prototype.apply</code>, <code class="language-html highlighter-rouge">Function.prototype.call</code> 메서드는 <code class="language-html highlighter-rouge">this</code>로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출합니다.<br />
<code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드의 사용법은 다음과 같습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="cm">/**
 * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출합니다.
 * @param thisArg - this로 사용할 객체
 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체
 * @returns 호출된 함수의 반환값
 */</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">[,</span> <span class="nx">argsArray</span><span class="p">])</span> <span class="p">;</span>

<span class="cm">/**
 * 주어진 this 바인딩과 ,로 구분된 인수 리스트를 사용하여 함수를 호출합니다.
 * @param thisArg - this로 사용할 객체
 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트
 * @returns 호출된 함수의 반환값
 */</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">[,</span> <span class="nx">arg1</span><span class="p">[,</span> <span class="nx">arg2</span><span class="p">[,</span> <span class="p">...]]])</span> <span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">getThisBinding</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// this로 사용할 객체</span>
<span class="kd">const</span> <span class="nx">thisArg</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">());</span> <span class="c1">// window</span>

<span class="c1">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">));</span> <span class="c1">// {a: 1}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">));</span> <span class="c1">// {a: 1}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong><code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드의 본질적인 기능은 함수를 호출하는 것입니다.</strong><br />
<code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 <code class="language-html highlighter-rouge">this</code>에 바인딩합니다.</p>

<p><code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드는 호출한 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작합니다.<br />
위 예제는 호출할 함수, 즉 <code class="language-html highlighter-rouge">getThisBinding</code> 함수에 인수를 전달하지 않습니다.<br />
<code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드를 통해 <code class="language-html highlighter-rouge">getThisBinding</code> 함수를 호출하면서 인수를 전달해 봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">getThisBinding</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// this로 사용할 객체</span>
<span class="kd">const</span> <span class="nx">thisArg</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="c1">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span>
<span class="c1">// apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]));</span>
<span class="c1">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
<span class="c1">// {a: 1}</span>

<span class="c1">// call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="c1">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
<span class="c1">// {a: 1}</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">apply</code> 메서드는 호출할 함수의 인수를 배열로 묶어 전달합니다.<br />
<code class="language-html highlighter-rouge">call</code> 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달합니다.<br />
이처럼 <code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 <code class="language-html highlighter-rouge">this</code>로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일합니다.</p>

<p><code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드의 대표적인 용도는 <code class="language-html highlighter-rouge">arguments</code> 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우입니다.<br />
<code class="language-html highlighter-rouge">arguments</code> 객체는 배열이 아니기 때문에 <code class="language-html highlighter-rouge">Array.prototype.slice</code> 같은 배열의 메서드를 사용할 수 없으나 <code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드를 이용하면 가능합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">convertArgsToArray</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>

  <span class="c1">// arguments 객체를 배열로 변환</span>
  <span class="c1">// Array.prototype.slice를 인수없이 호출하면 배열의 복사본을 생성한다.</span>
  <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// const arr = Array.prototype.slice.apply(arguments);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">convertArgsToArray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Function.prototype.bind</code> 메서드는 <code class="language-html highlighter-rouge">apply</code>와 <code class="language-html highlighter-rouge">call</code> 메서드와 달리 함수를 호출하지 않고 <code class="language-html highlighter-rouge">this</code>로 사용할 객체만 전달합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">getThisBinding</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// this로 사용할 객체</span>
<span class="kd">const</span> <span class="nx">thisArg</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="c1">// bind 메서드는 함수에 this로 사용할 객체를 전달한다.</span>
<span class="c1">// bind 메서드는 함수를 호출하지는 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">));</span> <span class="c1">// getThisBinding</span>
<span class="c1">// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getThisBinding</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">)());</span> <span class="c1">// {a: 1}</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">bind</code> 메서드는 메서드의 <code class="language-html highlighter-rouge">this</code>와 메서드 내부의 중첩 함수 또는 콜백 함수의 <code class="language-html highlighter-rouge">this</code>가 불일치하는 문제를 해결하기 위해 유용하게 사용됩니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ①</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">foo</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">.`</span><span class="p">);</span> <span class="c1">// ② Hi! my name is .</span>
  <span class="c1">// 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.</span>
  <span class="c1">// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.</span>
  <span class="c1">// Node.js 환경에서 this.name은 undefined다.</span>
<span class="p">});</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">person.foo</code>의 콜백 함수가 호출되기 이전인 ①의 시점에서 <code class="language-html highlighter-rouge">this</code>는 <code class="language-html highlighter-rouge">foo</code> 메서드를 호출한 객체, 즉 <code class="language-html highlighter-rouge">person</code> 객체를 가리킵니다.<br />
그러나 <code class="language-html highlighter-rouge">person.foo</code>의 콜백 함수가 일반 함수로서 호출된 ②의 시점에서 <code class="language-html highlighter-rouge">this</code>는 전역 객체 <code class="language-html highlighter-rouge">window</code>를 가리킵니다.<br />
따라서 <code class="language-html highlighter-rouge">person.foo</code>의 콜백 함수 내부에서 <code class="language-html highlighter-rouge">this.name</code>은 <code class="language-html highlighter-rouge">window.name</code>과 같습니다.</p>

<p>이때 위 예제에서 <code class="language-html highlighter-rouge">person.foo</code>의 콜백 함수는 외부 함수 <code class="language-html highlighter-rouge">person.foo</code>를 돕는 핼퍼 함수(보조 함수) 역할을 하기 때문에 외부 함수 <code class="language-html highlighter-rouge">person.foo</code> 내부의 <code class="language-html highlighter-rouge">this</code>와 콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code>가 상이하면 문맥상 문제가 발생합니다.</p>

<p>따라서 콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code>를 외부 함수 내부의 <code class="language-html highlighter-rouge">this</code>와 일치시켜야 합니다.<br />
이때 <code class="language-html highlighter-rouge">bind</code> 메서드를 사용하여 <code class="language-html highlighter-rouge">this</code>를 일치시킬 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">foo</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">.`</span><span class="p">);</span> <span class="c1">// Hi! my name is Lee.</span>
<span class="p">});</span>
</code></pre></div></div>

<p><br /></p>

<p>지금까지 함수 호출 방식에 따라 <code class="language-html highlighter-rouge">this</code> 바인딩이 동적으로 결정되는 것에 대해 살펴보았습니다.<br />
이를 정리해 보면 다음과 같습니다.</p>

<table>
  <thead>
    <tr>
      <th>함수 호출 방식</th>
      <th>this 바인딩</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>일반 함수 호출</td>
      <td>전역 객체</td>
    </tr>
    <tr>
      <td>메서드 호출</td>
      <td>메서드를 호출한 객체</td>
    </tr>
    <tr>
      <td>생성자 함수 호출</td>
      <td>생성자 함수가 (미래에) 생성할 인스턴스</td>
    </tr>
    <tr>
      <td>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</td>
      <td>Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체</td>
    </tr>
  </tbody>
</table>

<p><br /><br /><br /><br /><br /></p>
:ET