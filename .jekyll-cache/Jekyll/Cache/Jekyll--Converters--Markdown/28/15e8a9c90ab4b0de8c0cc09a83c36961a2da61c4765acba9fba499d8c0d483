I"i<p><br /></p>

<h1 id="es6-함수의-추가-기능">ES6 함수의 추가 기능</h1>

<p><br /></p>

<h2 id="1-함수의-구분">1. 함수의 구분</h2>

<p>ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용되었습니다.<br />
자바스크립트의 함수는 일반적인 함수로서 호출할 수도 있고, <code class="language-html highlighter-rouge">new</code> 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출할 수도 있으며, 객체에 바인딩되어 메서드로서 호출할 수도 있습니다.<br />
이는 언뜻 보면 편리한 것 같지만 실수를 유발시킬 수 있으며 성능 면에서도 손해입니다.</p>

<p>다음 예제를 살펴봅시다.<br />
ES6 이전의 함수는 동일한 함수라도 다양한 형태로 호출할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 일반적인 함수로서 호출</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; 1</span>

<span class="c1">// 생성자 함수로서 호출</span>
<span class="k">new</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; foo {}</span>

<span class="c1">// 메서드로서 호출</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span> <span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; 1</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않습니다.<br />
즉, <strong>ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있습니다.</strong><br />
다시 말해, ES6 이전의 모든 함수는 <code class="language-html highlighter-rouge">callable</code> 이면서 <code class="language-html highlighter-rouge">constructor</code> 입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>

<span class="c1">// ES6 이전의 모든 함수는 callable이면서 constructor다.</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; undefined</span>
<span class="k">new</span> <span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; foo {}</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p><strong><code class="language-html highlighter-rouge">callable</code> 과 <code class="language-html highlighter-rouge">constructor</code> / <code class="language-html highlighter-rouge">non-constructor</code></strong><br />
호출할 수 있는 함수 객체를 <code class="language-html highlighter-rouge">callable</code> 이라 하며, 인스턴스를 생성할 수 있는 객체를 <code class="language-html highlighter-rouge">constructor</code>, 인스턴스를 생성할 수 없는 객체를 <code class="language-html highlighter-rouge">non-constructor</code> 라고 부릅니다.</p>
</blockquote>

<p><br /></p>

<p>주의할 것은 ES6 이전에 일반적으로 메서드라고 부르던 객체에 바인딩된 함수도 <code class="language-html highlighter-rouge">callable</code> 이며 <code class="language-html highlighter-rouge">constructor</code> 라는 것입니다.<br />
따라서 객체에 바인딩된 함수도 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수도 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로퍼티 f에 바인딩된 함수는 callable이며 constructor다.</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="na">f</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">f</span><span class="p">());</span> <span class="c1">// 10</span>

<span class="c1">// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">f</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">());</span> <span class="c1">// undefined</span>

<span class="c1">// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">f</span><span class="p">());</span> <span class="c1">// f {}</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제와 같이 객체에 바인딩된 함수를 생성자 함수로 호출하는 경우가 흔치는 않겠지만 문법상 가능하다는 것은 문제가 있습니다.<br />
그리고 이는 성능 면에서도 문제가 있습니다.</p>

<p><strong>객체에 바인딩된 함수가 <code class="language-html highlighter-rouge">constructor</code> 라는 것은 객체에 바인딩된 함수가 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문입니다.</strong></p>

<p>함수에 전달되어 보조 함수의 역할을 수행하는 콜백 함수도 마찬가지입니다.<br />
콜백 함수도 <code class="language-html highlighter-rouge">constructor</code> 이기 때문에 불필요한 프로토타입 객체를 생성합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 콜백 함수를 사용하는 고차 함수 map. 콜백 함수도 constructor이며 프로토타입을 생성한다.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span> <span class="c1">// -&gt; [ 2, 4, 6 ]</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없으므로 호출 방식에 특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성합니다.<br />
이는 혼란스러우며 실수를 유발할 가능성이 있고 성능에도 좋지 않습니다.</p>

<p>이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했습니다.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>ES6 함수의 구분</th>
      <th>constructor</th>
      <th>prototype</th>
      <th>super</th>
      <th>arguments</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>일반 함수(Normal)</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
      <td>O</td>
    </tr>
    <tr>
      <td>메서드(Method)</td>
      <td>X</td>
      <td>X</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>화살표 함수(Arrow)</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>일반 함수는 함수 선언문이나 함수 표현식으로 정의한 함수를 말하며, ES6 이전의 함수와 차이가 없습니다.<br />
하지만 ES6의 메서드와 화살표 함수는 ES6 이전의 함수와 명확한 차이가 있습니다.</p>

<p>일반 함수는 <code class="language-html highlighter-rouge">constructor</code> 이지만 ES6의 메서드와 화살표 함수는 <code class="language-html highlighter-rouge">non-constructor</code> 입니다.<br />
이에 대해 좀 더 자세히 살펴봅시다.</p>

<p><br /><br /></p>

<h2 id="2-메서드">2. 메서드</h2>

<p>ES6 이전 사양에는 메서드에 대한 명확한 정의가 없었습니다.<br />
일반적으로 메서드는 객체에 바인딩된 함수를 일컫는 의미로 사용되었습니다.<br />
ES6 사양에서는 메서드에 대한 정의가 명확하게 규정되었습니다.</p>

<p><strong>ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미합니다.</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="c1">// foo는 메서드이다.</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="c1">// bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.</span>
  <span class="na">bar</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">());</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">());</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>ES6 사양에서 정의한 메서드(이하 ES6 메서드)는 인스턴스를 생성할 수 없는 <code class="language-html highlighter-rouge">non-constructor</code> 입니다.</strong><br />
따라서 ES6 메서드는 생성자 함수로서 호출할 수 없습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">new</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// -&gt; TypeError: obj.foo is not a constructor</span>
<span class="k">new</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span> <span class="c1">// -&gt; bar {}</span>
</code></pre></div></div>

<p><br /></p>

<p>ES6 메서드는 인스턴스를 생성할 수 없으므로 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티가 없고 프로토타입도 생성하지 않습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; false</span>

<span class="c1">// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; true</span>
</code></pre></div></div>

<p><br /></p>

<p>참고로 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 <code class="language-html highlighter-rouge">non-constructor</code> 입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>

<span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>
<span class="nb">Number</span><span class="p">.</span><span class="nb">isFinite</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; undefined</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 <code class="language-html highlighter-rouge">[[HomeObject]]</code> 를 갖습니다.</strong><br />
<code class="language-html highlighter-rouge">super</code> 참조는 내부 슬롯 <code class="language-html highlighter-rouge">[[HomeObject]]</code>를 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 <code class="language-html highlighter-rouge">[[HomeObject]]</code> 를 갖는 ES6 메서드는 <code class="language-html highlighter-rouge">super</code> 키워드를 사용할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">base</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`Hi! </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">derived</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="nx">base</span><span class="p">,</span>
  <span class="c1">// sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.</span>
  <span class="c1">// sayHi의 [[HomeObject]]는 sayHi가 바인딩된 객체인 derived를 가리키고</span>
  <span class="c1">// super는 sayHi의 [[HomeObject]]의 프로토타입인 base를 가리킨다.</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="k">super</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">()}</span><span class="s2">. how are you doing?`</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">derived</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">());</span> <span class="c1">// Hi! Lee. how are you doing?</span>
</code></pre></div></div>

<p><br /></p>

<p>ES6 메서드가 아닌 함수는 <code class="language-html highlighter-rouge">super</code> 키워드를 사용할 수 없습니다.<br />
ES6 메서드가 아닌 함수는 내부 슬롯 <code class="language-html highlighter-rouge">[[HomeObject]]</code> 를 갖지 않기 때문입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">derived</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="nx">base</span><span class="p">,</span>
  <span class="c1">// sayHi는 ES6 메서드가 아니다.</span>
  <span class="c1">// 따라서 sayHi는 [[HomeObject]]를 갖지 않으므로 super 키워드를 사용할 수 없다.</span>
  <span class="na">sayHi</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// SyntaxError: 'super' keyword unexpected here</span>
    <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="k">super</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">()}</span><span class="s2">. how are you doing?`</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 ES6 메서드는 본연의 기능(<code class="language-html highlighter-rouge">super</code>)을 추가하고 의미적으로 맞지 않는 기능(<code class="language-html highlighter-rouge">constructor</code>)은 제거했습니다.<br />
따라서 메서드를 정의할 때 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전의 방식을 사용하지 않는 것이 좋습니다.</p>

<p><br /><br /></p>

<h2 id="3-화살표-함수">3. 화살표 함수</h2>

<p>화살표 함수(arrow function)는 <code class="language-html highlighter-rouge">function</code> 키워드 대신 화살표(<code class="language-html highlighter-rouge">=&gt;</code>, fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있습니다.<br />
화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기존의 함수보다 간략합니다.<br />
특히 화살표 함수는 콜백 함수 내부에서 <code class="language-html highlighter-rouge">this</code> 가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용합니다.</p>

<p><br /></p>

<h3 id="31-화살표-함수-정의">3.1 화살표 함수 정의</h3>

<p>화살표 함수 정의 문법은 다음과 같습니다.</p>

<h4 id="함수-정의">함수 정의</h4>

<p>화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 합니다.<br />
호출 방식은 기존 함수와 동일합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="nx">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// -&gt; 6</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="매개변수-선언">매개변수 선언</h4>

<p>매개변수가 여러 개인 경우 소괄호 <code class="language-html highlighter-rouge">()</code> 안에 매개변수를 선언합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>매개변수가 한 개인 경우 소괄호 <code class="language-html highlighter-rouge">()</code> 를 생략할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>매개변수가 없는 경우 소괄호 <code class="language-html highlighter-rouge">()</code> 를 생략할 수 없습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="함수-몸체-정의">함수 몸체 정의</h4>

<p>함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 <code class="language-html highlighter-rouge">{}</code> 를 생략할 수 있습니다.<br />
이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환됩니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// concise body</span>
<span class="kd">const</span> <span class="nx">power</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">power</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// -&gt; 4</span>

<span class="c1">// 위 표현은 다음과 동일하다.</span>
<span class="c1">// block body</span>
<span class="kd">const</span> <span class="nx">power</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>함수 몸체를 감싸는 중괄호 <code class="language-html highlighter-rouge">{}</code> 를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생합니다.<br />
표현식이 아닌 문은 반환할 수 없기 때문입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// SyntaxError: Unexpected token 'const'</span>

<span class="c1">// 위 표현은 다음과 같이 해석된다.</span>
<span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 <code class="language-html highlighter-rouge">()</code> 로 감싸주어야 합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">create</span> <span class="o">=</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">content</span> <span class="p">});</span>
<span class="nx">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; {id: 1, content: "JavaScript"}</span>

<span class="c1">// 위 표현은 다음과 동일하다.</span>
<span class="kd">const</span> <span class="nx">create</span> <span class="o">=</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">content</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>객체 리터럴을 소괄호 <code class="language-html highlighter-rouge">()</code> 로 감싸지 않으면 객체 리터럴의 중괄호 <code class="language-html highlighter-rouge">{}</code> 를 함수 몸체를 감싸는 중괄호 <code class="language-html highlighter-rouge">{}</code> 로 잘못 해석합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// { id, content }를 함수 몸체 내의 쉼표 연산자문으로 해석한다.</span>
<span class="kd">const</span> <span class="nx">create</span> <span class="o">=</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">id</span><span class="p">,</span> <span class="nx">content</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">JavaScript</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; undefined</span>
</code></pre></div></div>

<p><br /></p>

<p>함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 <code class="language-html highlighter-rouge">{}</code> 를 생략할 수 없습니다.<br />
이때 반환값이 있다면 명시적으로 반환해야 합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수도 즉시 실행 함수(IIFE)로 사용할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">((</span><span class="nx">name</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`Hi? My name is </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">.`</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">}))(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">());</span> <span class="c1">// Hi? My name is Lee.</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수도 일급 객체이므로 <code class="language-html highlighter-rouge">Array.prototype.map</code>, <code class="language-html highlighter-rouge">Array.prototype.filter</code>, <code class="language-html highlighter-rouge">Array.prototype.reduce</code> 같은 고차 함수(Higher-Order Function, HOF)에 인수로 전달할 수 있습니다.<br />
이 경우 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// ES5</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// ES6</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// -&gt; [ 2, 4, 6 ]</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 화살표 함수는 콜백 함수로서 정의할 때 유용합니다.<br />
화살표 함수는 표현만 간략한 것만이 아닙니다.<br />
화살표 함수는 일반 함수의 기능을 간략화했으며 <code class="language-html highlighter-rouge">this</code> 도 편리하게 설계되었습니다.<br />
일반 함수와 화살표 함수의 차이에 대해 살펴봅시다.</p>

<p><br /></p>

<h3 id="32-화살표-함수와-일반-함수의-차이">3.2 화살표 함수와 일반 함수의 차이</h3>

<p>화살표 함수와 일반 함수의 차이는 다음과 같습니다.</p>

<p><br /></p>

<h4 id="1-화살표-함수는-인스턴스를-생성할-수-없는-non-constructor-입니다">1. 화살표 함수는 인스턴스를 생성할 수 없는 <code class="language-html highlighter-rouge">non-constructor</code> 입니다.</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
<span class="c1">// 화살표 함수는 생성자 함수로서 호출할 수 없다.</span>
<span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span> <span class="c1">// TypeError: Foo is not a constructor</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수는 인스턴스를 생성할 수 없으므로 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티가 없고 프로토타입도 생성하지 않습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
<span class="c1">// 화살표 함수는 prototype 프로퍼티가 없다.</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; false</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="2-중복된-매개변수-이름을-선언할-수-없습니다">2. 중복된 매개변수 이름을 선언할 수 없습니다.</h4>

<p>일반 함수는 중복된 매개변수 이름을 선언해도 에러가 발생하지 않습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">normal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 4</span>
</code></pre></div></div>

<p><br /></p>

<p>단, <code class="language-html highlighter-rouge">strict mode</code> 에서 중복된 매개변수 이름을 선언하면 에러가 발생합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">normal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수에서도 중복된 매개변수 이름을 선언하면 에러가 발생합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">a</span><span class="p">;</span>
<span class="c1">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="3-화살표-함수는-함수-자체의-this-arguments-super-newtarget-바인딩을-갖지-않습니다">3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않습니다.</h4>

<p>따라서 화살표 함수 내부에서 <code class="language-html highlighter-rouge">this</code>, <code class="language-html highlighter-rouge">arguments</code>, <code class="language-html highlighter-rouge">super</code>, <code class="language-html highlighter-rouge">new.target</code> 을 참조하면 스코프 체인을 통해 상위 스코프의 <code class="language-html highlighter-rouge">this</code>, <code class="language-html highlighter-rouge">arguments</code>, <code class="language-html highlighter-rouge">super</code>, <code class="language-html highlighter-rouge">new.target</code> 을 참조합니다.</p>

<p>만약 화살표 함수와 화살표 함수가 중첩되어 있다면 상위 화살표 함수에도 <code class="language-html highlighter-rouge">this</code>, <code class="language-html highlighter-rouge">arguments</code>, <code class="language-html highlighter-rouge">super</code>, <code class="language-html highlighter-rouge">new.target</code> 바인딩이 없으므로 스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 <code class="language-html highlighter-rouge">this</code>, <code class="language-html highlighter-rouge">arguments</code>, <code class="language-html highlighter-rouge">super</code>, <code class="language-html highlighter-rouge">new.target</code> 을 참조합니다.</p>

<p><br /></p>

<h3 id="33-this">3.3 this</h3>

<p>화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 바로 <code class="language-html highlighter-rouge">this</code> 입니다.<br />
그리고 화살표 함수는 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우가 많습니다.</p>

<p>화살표 함수의 <code class="language-html highlighter-rouge">this</code> 는 일반 함수의 <code class="language-html highlighter-rouge">this</code> 와 다르게 동작합니다.<br />
이는 “콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”, 즉 콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 가 외부 함수의 <code class="language-html highlighter-rouge">this</code> 와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것입니다.<br />
“콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”에 대해 다시 한번 살펴봅시다.</p>

<p><code class="language-html highlighter-rouge">this</code> 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정됩니다.<br />
다시 말해, 함수를 정의할 때 <code class="language-html highlighter-rouge">this</code> 에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 <code class="language-html highlighter-rouge">this</code> 에 바인딩할 객체가 동적으로 결정됩니다.</p>

<p>이때 주의할 것은 일반 함수로서 호출되는 콜백 함수의 경우입니다.<br />
고차 함수(Higher-Order Funcdtion, HOF)의 인수로 전달되어 고차 함수 내부에서 호출되는 콜백 함수도 중첩 함수라고 할 수 있습니다.<br />
주어진 배열의 각 요소에 접두어를 추가하는 다음 예제를 살펴봅시다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">class</span> <span class="nx">Prefixer</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">=</span> <span class="nx">prefix</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">add</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// add 메서드는 인수로 전달된 배열 arr을 순회하며 배열의 모든 요소에 prefix를 추가한다.</span>
    <span class="c1">// ①</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="nx">item</span><span class="p">;</span> <span class="c1">// ②</span>
      <span class="c1">// -&gt; TypeError: Cannot read property 'prefix' of undefined</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">prefixer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Prefixer</span><span class="p">(</span><span class="dl">"</span><span class="s2">-webkit-</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixer</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span><span class="dl">"</span><span class="s2">transition</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">user-select</span><span class="dl">"</span><span class="p">]));</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제를 실행했을 때 기대하는 결과는 <code class="language-html highlighter-rouge">['-webkit-transition', '-webkit-user-select']</code> 입니다.<br />
하지만 <code class="language-html highlighter-rouge">TypeError</code> 가 발생합니다.<br />
그 이유에 대해 살펴봅시다.</p>

<p>프로토타입 메서드 내부인 ①에서 <code class="language-html highlighter-rouge">this</code> 는 메서드를 호출한 객체(위 예제의 경우 <code class="language-html highlighter-rouge">prefixer</code> 객체)를 가리킵니다.<br />
그런데 <code class="language-html highlighter-rouge">Array.prototype.map</code> 의 인수로 전달한 콜백 함수의 내부인 ②에서 <code class="language-html highlighter-rouge">this</code> 는 <code class="language-html highlighter-rouge">undefined</code> 를 가리킵니다.<br />
이는 <code class="language-html highlighter-rouge">Array.prototype.map</code> 메서드가 콜백 함수를 일반 함수로서 호출하기 때문입니다.</p>

<p><br /></p>

<blockquote>
  <p><strong><code class="language-html highlighter-rouge">Array.prototype.map</code> 메서드</strong><br />
<code class="language-html highlighter-rouge">Array.prototype.map</code> 메서드는 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 호출합니다.<br />
그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환합니다.<br />
위 예제에서 <code class="language-html highlighter-rouge">map</code> 메서드는 매개변수 <code class="language-html highlighter-rouge">arr</code> 에 전달된 <code class="language-html highlighter-rouge">['transition', 'user-select']</code> 를 순회하며 콜백 함수의 <code class="language-html highlighter-rouge">item</code> 매개변수에게 <code class="language-html highlighter-rouge">arr</code> 의 요소값을 전달하면서 콜백 함수를 <code class="language-html highlighter-rouge">arr</code> 의 요소 개수만큼 호출합니다.<br />
그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환합니다.</p>
</blockquote>

<p><br /></p>

<p>일반 함수로서 호출되는 모든 함수 내부의 <code class="language-html highlighter-rouge">this</code> 는 전역 객체를 가리킵니다.<br />
그런데 클래스 내부의 모든 코드에는 <code class="language-html highlighter-rouge">strict mode</code> 가 암묵적으로 적용됩니다.<br />
따라서 <code class="language-html highlighter-rouge">Array.prototype.map</code> 메서드의 콜백 함수에도 <code class="language-html highlighter-rouge">strict mode</code> 가 적용됩니다.<br />
<code class="language-html highlighter-rouge">strict mode</code> 에서 일반 함수로서 호출된 모든 함수 내부의 <code class="language-html highlighter-rouge">this</code> 에는 전역 객체가 아니라 <code class="language-html highlighter-rouge">undefined</code> 가 바인딩되므로 일반 함수로서 호출되는 <code class="language-html highlighter-rouge">Array.prototype.map</code> 메서드의 콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 에는 <code class="language-html highlighter-rouge">undefined</code> 가 바인딩됩니다.</p>

<p>이때 발생하는 문제가 바로 “콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”입니다.<br />
즉, 콜백 함수의 <code class="language-html highlighter-rouge">this</code>(②)와 외부 함수의 <code class="language-html highlighter-rouge">this</code>(①)가 서로 다른 값을 가리키고 있기 때문에 <code class="language-html highlighter-rouge">TypeError</code> 가 발생한 것입니다.<br />
이와 같은 “콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”를 해결하기 위해 ES6 이전에는 다음과 같은 방법을 사용했습니다.</p>

<p><br /></p>

<h4 id="1-add-메서드를-호출한-prefixer-객체를-가리키는-this를-일단-회피시킨-후에-콜백-함수-내부에서-사용합니다">1. add 메서드를 호출한 prefixer 객체를 가리키는 this를 일단 회피시킨 후에 콜백 함수 내부에서 사용합니다.</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">...</span>
<span class="nx">add</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// this를 일단 회피시킨다.</span>
  <span class="kd">const</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this 대신 that을 참조한다.</span>
    <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="2-arrayprototypemap의-두-번째-인수로-add-메서드를-호출한-prefixer-객체를-가리키는-this-를-전달합니다">2. Array.prototype.map의 두 번째 인수로 add 메서드를 호출한 prefixer 객체를 가리키는 this 를 전달합니다.</h4>

<p>ES5에서 도입된 <code class="language-html highlighter-rouge">Array.prototype.map</code>은 “콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”를 해결하기 위해 두 번쨰 인수로 콜백 함수 내부에서 <code class="language-html highlighter-rouge">this</code> 로 사용할 객체를 전달할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">...</span>
<span class="nx">add</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">;</span>
  <span class="p">},</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// this에 바인딩된 값이 콜백 함수 내부의 this에 바인딩된다.</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="3-functionprototypebind-메서드를-사용하여-add-메서드를-호출한-prefixer-객체를-가리키는-this-를-바인딩합니다">3. Function.prototype.bind 메서드를 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this 를 바인딩합니다.</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">...</span>
<span class="nx">add</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">item</span><span class="p">;</span>
  <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span> <span class="c1">// this에 바인딩된 값이 콜백 함수 내부의 this에 바인딩된다.</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p><br /></p>

<p>ES6에서는 화살표 함수를 사용하여 “콜백 함수 내부의 <code class="language-html highlighter-rouge">this</code> 문제”를 해결할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">class</span> <span class="nx">Prefixer</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">=</span> <span class="nx">prefix</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">add</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">+</span> <span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">prefixer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Prefixer</span><span class="p">(</span><span class="dl">"</span><span class="s2">-webkit-</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prefixer</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span><span class="dl">"</span><span class="s2">transition</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">user-select</span><span class="dl">"</span><span class="p">]));</span>
<span class="c1">// ['-webkit-transition', '-webkit-user-select']</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">this</code> 바인딩을 갖지 않습니다.</strong><br />
<strong>따라서 화살표 함수 내부에서 <code class="language-html highlighter-rouge">this</code> 를 참조하면 상위 스코프의 <code class="language-html highlighter-rouge">this</code> 를 그대로 참조합니다.</strong><br />
<strong>이를 lexical this 라 합니다.</strong></p>

<p>이는 마치 렉시컬 스코프와 같이 화살표 함수의 <code class="language-html highlighter-rouge">this</code> 가 함수가 정의된 위치에 의해 결정된다는 것을 의미합니다.</p>

<p>화살표 함수를 제외한 모든 함수에는 <code class="language-html highlighter-rouge">this</code> 바인딩이 반드시 존재합니다.<br />
따라서 ES6에서 화살표 함수가 도입되기 이전에는 일반적인 식별자처럼 스코프 체인을 통해 <code class="language-html highlighter-rouge">this</code> 를 탐색할 필요가 없었습니다.<br />
하지만 화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">this</code> 바인딩이 존재하지 않습니다.<br />
따라서 화살표 함수 내부에서 <code class="language-html highlighter-rouge">this</code> 를 참조하면 일반적인 식별자처럼 스코프 체인을 통해 상위 스코프에서 <code class="language-html highlighter-rouge">this</code> 를 탐색합니다.</p>

<p>화살표 함수를 <code class="language-html highlighter-rouge">Function.prototype.bind</code> 를 사용하여 표현하면 다음과 같습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 화살표 함수는 상위 스코프의 this를 참조한다.</span>
<span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>

<span class="c1">// 익명 함수에 상위 스코프의 this를 주입한다. 위 화살표 함수와 동일하게 동작한다.</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
<span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</code></pre></div></div>

<p><br /></p>

<p>만약 화살표 함수와 화살표 함수가 중첩되어 있다면 상위 화살표 함수에도 <code class="language-html highlighter-rouge">this</code> 바인딩이 없으므로 스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 <code class="language-html highlighter-rouge">this</code> 를 참조합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 중첩 함수 foo의 상위 스코프는 즉시 실행 함수다.</span>
<span class="c1">// 따라서 화살표 함수 foo의 this는 상위 스코프인 즉시 실행 함수의 this를 가리킨다.</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="nx">foo</span><span class="p">();</span>
<span class="p">}.</span><span class="nx">call</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}));</span> <span class="c1">// { a: 1 }</span>

<span class="c1">// bar 함수는 화살표 함수를 반환한다.</span>
<span class="c1">// bar 함수가 반환한 화살표 함수의 상위 스코프는 화살표 함수 bar다.</span>
<span class="c1">// 하지만 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 bar 함수가 반환한</span>
<span class="c1">// 화살표 함수 내부에서 참조하는 this는 화살표 함수가 아닌 즉시 실행 함수의 this를 가리킨다.</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="nx">bar</span><span class="p">()();</span>
<span class="p">}.</span><span class="nx">call</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}));</span> <span class="c1">// { a: 1 }</span>
</code></pre></div></div>

<p><br /></p>

<p>만약 화살표 함수가 전역 함수라면 화살표 함수의 <code class="language-html highlighter-rouge">this</code> 는 전역 객체를 가리킵니다.<br />
전역 함수의 상위 스코프는 전역이고 전역에서 <code class="language-html highlighter-rouge">this</code> 는 전역 객체를 가리키기 때문입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 전역 함수 foo의 상위 스코프는 전역이므로 화살표 함수 foo의 this는 전역 객체를 가리킨다.</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// window</span>
</code></pre></div></div>

<p><br /></p>

<p>프로퍼티에 할당한 화살표 함수도 스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 <code class="language-html highlighter-rouge">this</code> 를 참조합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// increase 프로퍼티에 할당한 화살표 함수의 상위 스코프는 전역이다.</span>
<span class="c1">// 따라서 increase 프로퍼티에 할당한 화살표 함수의 this는 전역 객체를 가리킨다.</span>
<span class="kd">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">num</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">increase</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">num</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">increase</span><span class="p">());</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">this</code> 바인딩을 갖지 않기 때문에 <code class="language-html highlighter-rouge">Function.prototype.call</code>, <code class="language-html highlighter-rouge">Function.prototype.apply</code>, <code class="language-html highlighter-rouge">Function.prototype.bind</code> 메서드를 사용해도 화살표 함수 내부의 <code class="language-html highlighter-rouge">this</code> 를 교체할 수 없습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">window</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">normal</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">normal</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}));</span> <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arrow</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}));</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<p>화살표 함수가 <code class="language-html highlighter-rouge">Function.prototype.call</code>, <code class="language-html highlighter-rouge">Function.prototype.apply</code>, <code class="language-html highlighter-rouge">Function.prototype.bind</code> 메서드를 호출할 수 없다는 의미는 아닙니다.<br />
화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">this</code> 바인딩을 갖지 않기 때문에 <code class="language-html highlighter-rouge">this</code> 를 교체할 수 없고 언제나 상위 스코프의 <code class="language-html highlighter-rouge">this</code> 바인딩을 참조합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]));</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)());</span> <span class="c1">// 3</span>
</code></pre></div></div>

<p><br /></p>

<p>메서드를 화살표 함수로 정의하는 것은 피해야 합니다.<br />
화살표 함수로 메서드를 정의하여 봅시다.<br />
여기서 말하는 메서드는 ES6 메서드가 아닌 일반적인 의미의 메서드를 말합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Bad</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">sayHi</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">),</span>
<span class="p">};</span>

<span class="c1">// sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는</span>
<span class="c1">// 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는</span>
<span class="c1">// window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제의 경우 <code class="language-html highlighter-rouge">sayHi</code> 프로퍼티에 할당한 화살표 함수 내부의 <code class="language-html highlighter-rouge">this</code> 는 메서드를 호출한 객체인 <code class="language-html highlighter-rouge">person</code> 을 가리키지 않고 상위 스코프인 전역의 <code class="language-html highlighter-rouge">this</code> 가 가리키는 전역 객체를 가리킵니다.<br />
따라서 화살표 함수로 메서드를 정의하는 것은 바람직하지 않습니다.<br />
메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Good</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>프로토타입 객체의 프로퍼티에 화살표 함수를 할당하는 경우도 동일한 문제가 발생합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Bad</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi</span>
</code></pre></div></div>

<p><br /></p>

<p>프로퍼티를 동적 추가할 때는 ES6 메서드 정의를 사용할 수 없으므로 일반 함수를 할당합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Good</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>일반 함수가 아닌 ES6 메서드를 동적 추가하고 싶다면 다음과 같이 객체 리터럴을 바인딩하고 프로토타입의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티와 생성자 함수 간의 연결을 재설정합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// constructor 프로퍼티와 생성자 함수 간의 연결을 재설정</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="nx">Person</span><span class="p">,</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Bad</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="c1">// 클래스 필드 정의 제안</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">sayHi</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>이때 <code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수 내부에서 <code class="language-html highlighter-rouge">this</code> 를 참조하면 상위 스코프의 <code class="language-html highlighter-rouge">this</code> 바인딩을 참조합니다.<br />
그렇다면 <code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수의 상위 스코프는 무엇일까요?<br />
<code class="language-html highlighter-rouge">sayHi</code> 클래스 필드는 인스턴스 프로퍼티이므로 다음과 같은 의미입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">;</span>
    <span class="c1">// 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.</span>
    <span class="c1">// sayHi 프로퍼티는 인스턴스 프로퍼티이다.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수의 상위 스코프는 <code class="language-html highlighter-rouge">constructor</code> 입니다.<br />
따라서 <code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수 내부에서 참조한 <code class="language-html highlighter-rouge">this</code> 는 <code class="language-html highlighter-rouge">constructor</code> 내부의 <code class="language-html highlighter-rouge">this</code> 바인딩과 같습니다.<br />
<code class="language-html highlighter-rouge">constructor</code> 내부의 <code class="language-html highlighter-rouge">this</code> 바인딩은 클래스가 생성한 인스턴스를 가리키므로 <code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수 내부의 <code class="language-html highlighter-rouge">this</code> 또한 클래스가 생성한 인스턴스를 가리킵니다.</p>

<p>하지만 클래스 필드에 할당한 화살표 함수는 프로토타입 메서드가 아니라 인스턴스 메서드가 됩니다.<br />
따라서 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Good</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="c1">// 클래스 필드 정의</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">;</span>

  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hi Lee</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="34-super">3.4 super</h3>

<p>화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">super</code> 바인딩을 갖지 않습니다.<br />
따라서 화살표 함수 내부에서 <code class="language-html highlighter-rouge">super</code> 를 참조하면 <code class="language-html highlighter-rouge">this</code> 와 마찬가지로 상위 스코프의 <code class="language-html highlighter-rouge">super</code> 를 참조합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">class</span> <span class="nx">Base</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`Hi! </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Derived</span> <span class="kd">extends</span> <span class="nx">Base</span> <span class="p">{</span>
  <span class="c1">// 화살표 함수의 super는 상위 스코프인 constructor의 super를 가리킨다.</span>
  <span class="nx">sayHi</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="k">super</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">()}</span><span class="s2"> how are you doing?`</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">derived</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Derived</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">derived</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">());</span> <span class="c1">// Hi! Lee how are you doing?</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">super</code> 는 내부 슬롯 <code class="language-html highlighter-rouge">[[HomeObject]]</code> 를 갖는 ES6 메서드 내에서만 사용할 수 있는 키워드입니다.<br />
<code class="language-html highlighter-rouge">sayHi</code> 클래스 필드에 할당한 화살표 함수는 ES6 메서드는 아니지만 함수 자체의 <code class="language-html highlighter-rouge">super</code> 바인딩을 갖지 않으므로 <code class="language-html highlighter-rouge">super</code> 를 참조해도 에러가 발생하지 않고 상위 스코프인 <code class="language-html highlighter-rouge">constructor</code> 의 <code class="language-html highlighter-rouge">super</code> 바인딩을 참조합니다.</p>

<p><br /></p>

<h3 id="35-arguments">3.5 arguments</h3>

<p>화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">arguments</code> 바인딩을 갖지 않습니다.<br />
따라서 화살표 함수 내부에서 <code class="language-html highlighter-rouge">arguments</code> 를 참조하면 <code class="language-html highlighter-rouge">this</code> 와 마찬가지로 상위 스코프의 <code class="language-html highlighter-rouge">arguments</code> 를 참조합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 화살표 함수 foo의 arguments는 상위 스코프인 즉시 실행 함수의 arguments를 가리킨다.</span>
  <span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [Arguments] { '0': 1, '1': 2 }</span>
  <span class="nx">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">})(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// 화살표 함수 foo의 arguments는 상위 스코프인 전역의 arguments를 가리킨다.</span>
<span class="c1">// 하지만 전역에는 arguments 객체가 존재하지 않는다. arguments 객체는 함수 내부에서만 유효하다.</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// ReferenceError: arguments is not defined</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">arguments</code> 객체는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용합니다.<br />
하지만 화살표 함수에서는 <code class="language-html highlighter-rouge">arguments</code> 객체를 사용할 수 없습니다.<br />
상위 스코프의 <code class="language-html highlighter-rouge">arguments</code> 객체를 참조할 수는 있지만 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없고 상위 함수에게 전달된 인수 목록을 참조하므로 그다지 도움이 되지 않습니다.</p>

<p>따라서 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 합니다.</p>

<p><br /><br /></p>

<h2 id="4-rest-파라미터">4. Rest 파라미터</h2>

<h3 id="41-기본-문법">4.1 기본 문법</h3>

<p>Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 <code class="language-html highlighter-rouge">...</code> 을 붙여서 정의한 매개변수를 의미합니다.<br />
<strong>Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받습니다.</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rest</span><span class="p">);</span> <span class="c1">// [ 1, 2, 3, 4, 5 ]</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>일반 매개변수와 Rest 파라미터는 함께 사용할 수 있습니다.<br />
이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당됩니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">param</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">param</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rest</span><span class="p">);</span> <span class="c1">// [ 2, 3, 4, 5 ]</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">param1</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">param2</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rest</span><span class="p">);</span> <span class="c1">// [ 3, 4, 5 ]</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당됩니다.<br />
따라서 Rest 파라미터는 반드시 마지막 파라미터이어야 합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(...</span><span class="nx">rest</span><span class="p">,</span> <span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">// SyntaxError: Rest parameter must be last formal parameter</span>
</code></pre></div></div>

<p><br /></p>

<p>Rest 파라미터는 단 하나만 선언할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(...</span><span class="nx">rest1</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest2</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">// SyntaxError: Rest parameter must be last formal parameter</span>
</code></pre></div></div>

<p><br /></p>

<p>Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 <code class="language-html highlighter-rouge">length</code> 프로퍼티에 영향을 주지 않습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 0</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1</span>

<span class="kd">function</span> <span class="nx">baz</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">)</span> <span class="p">{}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">baz</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="42-rest-파라미터와-arguments-객체">4.2 Rest 파라미터와 arguments 객체</h3>

<p>ES5에서는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능하므로 <code class="language-html highlighter-rouge">arguments</code> 객체를 활용하여 인수를 전달받았습니다.<br />
<code class="language-html highlighter-rouge">arguments</code> 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한 유사 배열 객체(array-like object)이며, 함수 내부에서 지역 변수처럼 사용할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 매개변수의 개수를 사전에 알 수 없는 가변 인자 함수</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 가변 인자 함수는 arguments 객체를 통해 인수를 전달받는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// {length: 2, '0': 1, '1': 2}</span>
</code></pre></div></div>

<p><br /></p>

<p>하지만 <code class="language-html highlighter-rouge">arguments</code> 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드를 사용하려면 <code class="language-html highlighter-rouge">Function.prototype.call</code>이나 <code class="language-html highlighter-rouge">Function.prototype.apply</code> 메서드를 사용해 <code class="language-html highlighter-rouge">arguments</code> 객체를 배열로 변환해야 하는 번거로움이 있었습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 유사 배열 객체인 arguments 객체를 배열로 변환한다.</span>
  <span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pre</span> <span class="o">+</span> <span class="nx">cur</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span> <span class="c1">// 15</span>
</code></pre></div></div>

<p><br /></p>

<p>ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있습니다.<br />
이를 통해 유사 배열 객체인 <code class="language-html highlighter-rouge">arguments</code> 객체를 배열로 변환하는 번거로움을 피할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]가 할당된다.</span>
  <span class="k">return</span> <span class="nx">args</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">pre</span> <span class="o">+</span> <span class="nx">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span> <span class="c1">// 15</span>
</code></pre></div></div>

<p><br /></p>

<p>함수와 ES6 메서드는 Rest 파라미터와 <code class="language-html highlighter-rouge">arguments</code> 객체를 모두 사용할 수 있습니다.<br />
하지만 화살표 함수는 함수 자체의 <code class="language-html highlighter-rouge">arguments</code> 객체를 갖지 않습니다.<br />
따라서 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 합니다.</p>

<p><br /><br /></p>

<h2 id="5-매개변수-기본값">5. 매개변수 기본값</h2>

<p>함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않습니다.<br />
이는 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문입니다.</p>

<p>인수가 전달되지 않은 매개변수의 값은 <code class="language-html highlighter-rouge">undefined</code> 입니다.<br />
이를 방치하면 다음 예제와 같이 의도치 않은 결과가 나올 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 다음 예제와 같이 매개변수에 인수가 전달되었는지 확인하여 인수가 전달되지 않은 경우 매개변수에 기본값을 할당할 필요가 있습니다.<br />
즉, 방어 코드가 필요합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 인수가 전달되지 않아 매개변수의 값이 undefined인 경우 기본값을 할당한다.</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<p>ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<p>매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 <code class="language-html highlighter-rouge">undefined</code> 를 전달한 경우에만 유효합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">logName</span><span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">logName</span><span class="p">();</span> <span class="c1">// Lee</span>
<span class="nx">logName</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// Lee</span>
<span class="nx">logName</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// null</span>
</code></pre></div></div>

<p><br /></p>

<p>앞서 살펴본 Rest 파라미터에는 기본값을 지정할 수 없습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(...</span><span class="nx">rest</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rest</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// SyntaxError: Rest parameter may not have a default initializer</span>
</code></pre></div></div>

<p><br /></p>

<p>매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 <code class="language-html highlighter-rouge">length</code> 프로퍼티와 <code class="language-html highlighter-rouge">arguments</code> 객체에 아무런 영향을 주지 않습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Arguments { '0': 1 }</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Arguments { '0': 1, '1': 2 }</span>
</code></pre></div></div>

<p><br /><br /><br /><br /><br /></p>
:ET