I"J<p><br /></p>

<h1 id="변수">변수</h1>

<p><br /></p>

<h2 id="1-변수란-무엇인가-왜-필요한가">1. 변수란 무엇인가? 왜 필요한가?</h2>

<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공합니다.</p>

<p>변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말합니다.<br />
간단히 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름입니다.<br />
상징적 이름인 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됩니다.</p>

<p>메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름(또는 변수명)이라고 합니다.<br />
그리고 변수에 저장된 값을 변수 값이라고 합니다.<br />
변수에 값을 저장하는 것을 할당(대입, 저장)이라고 하고, 변수에 저장된 값을 읽어 들이는 것을 참조라고 합니다.</p>

<p>변수 이름은 사람을 위해 사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름입니다.<br />
변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환합니다.</p>

<p><br /></p>

<h2 id="2-식별자">2. 식별자</h2>

<p>변수 이름을 식별자라고도 합니다.<br />
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말합니다.<br />
식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 합니다.<br />
이처럼 식별자는 값이 아니라 메모리 주소를 기억하고 있습니다.</p>

<p>식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미입니다.<br />
즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있습니다.</p>

<p>변수, 함수, 클래스 등의 이름 같이 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부릅니다.<br />
식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알립니다.</p>

<p><br /></p>

<h2 id="3-변수-선언">3. 변수 선언</h2>

<p>변수 선언이란 변수를 생성하는 것을 말합니다.<br />
좀 더 자세히 말하면 값을 저장히기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.</p>

<p>변수를 사용하려면 반드시 선언이 필요합니다.<br />
변수를 선언할 때는 <code class="language-html highlighter-rouge">var</code>, <code class="language-html highlighter-rouge">let</code>, <code class="language-html highlighter-rouge">const</code> 키워드를 사용합니다.<br />
여기서 키워드란 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어입니다.<br />
자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행합니다.</p>

<p><br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언(변수 선언문)</span>
</code></pre></div></div>

<p>위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보합니다.<br />
확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화됩니다.</p>

<p><br /></p>

<p>자바스크립트 엔진은 변수 선언을 다음과 같은 2단계를 거쳐 수행합니다.</p>

<ul>
  <li>선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수 존재를 알립니다.</li>
  <li>초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화합니다.</li>
</ul>

<p><br /></p>

<blockquote>
  <p><strong>변수 이름은 어디에 등록될까요?</strong><br />
변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록됩니다.
실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역입니다.<br />
자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리합니다.</p>
</blockquote>

<p><br /></p>

<p><code class="language-html highlighter-rouge">var</code> 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행됩니다.<br />
<code class="language-html highlighter-rouge">var score;</code>는 선언 단계를 통해 변수 이름 <code class="language-html highlighter-rouge">score</code>를 등록하고, 초기화 단계를 통해 <code class="language-html highlighter-rouge">score</code> 변수에 암묵적으로 undefined를 할당해 초기화합니다.</p>

<p><br /></p>

<h2 id="4-변수-선언의-실행-시점과-변수-호이스팅">4. 변수 선언의 실행 시점과 변수 호이스팅</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// undefined, 참조에러가 발생하지 않음</span>

<span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언문</span>
</code></pre></div></div>

<p>변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에 실행됩니다.</p>

<p>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 합니다.<br />
이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행합니다.<br />
그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행합니다.</p>

<p>즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행합니다.<br />
따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든 변수를 참조 할 수 있습니다.</p>

<p>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 합니다.<br />
사실 변수 선언뿐 아니라 <code class="language-html highlighter-rouge">var</code>, <code class="language-html highlighter-rouge">let</code>, <code class="language-html highlighter-rouge">const</code>, <code class="language-html highlighter-rouge">function</code>, <code class="language-html highlighter-rouge">function*</code>, <code class="language-html highlighter-rouge">class</code> 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 됩니다.<br />
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문입니다.</p>

<p><br /></p>

<h2 id="5-값의-할당">5. 값의 할당</h2>

<p>변수에 값을 할당(대입, 저장)할 때는 할당 연산자 =를 사용합니다. 할당 연산자는 우변의 값을 좌변의 변수에 할당합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언</span>
<span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>
</code></pre></div></div>

<p><br /></p>

<p>변수 선언과 값의 할당을 다음과 같이 하나의 문(statement)으로 단축 표현할 수도 있습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됩니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언</span>
<span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// 80</span>
</code></pre></div></div>

<p><br /></p>

<p>변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>
<span class="kd">var</span> <span class="nx">score</span><span class="p">;</span> <span class="c1">// 변수 선언</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">score</span><span class="p">);</span> <span class="c1">// ??</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="6-값의-재할당">6. 값의 재할당</h2>

<p>재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 의미합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>
<span class="nx">score</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="c1">// 값의 재할당</span>
</code></pre></div></div>

<p><br /></p>

<p>재할당은 변수에 저장된 값을 다른 값으로 변경합니다.<br />
만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라고 합니다.<br />
상수는 한번 정해지면 변하지 않는 값입니다.<br />
다시 말해 상수는 단 한 번만 할당할 수 있는 변수입니다.</p>

<p>변수에 값을 재할당하면 score 변수의 값은 이전 값 80에서 재할당한 값 90으로 변경됩니다.<br />
처음 값을 할당했을 때와 마찬가지로 이전 값 80이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장합니다.</p>

<p>현재 score 변수의 값은 90입니다.<br />
score 변수의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않습니다.<br />
다시 말해, 어떤 식별자와도 연결되어 있지 않습니다.<br />
이것은 undefined와 80이 더 이상 필요하지 않다는 것을 의미합니다.<br />
아무도 사용하고 있지 않으니 필요하지 않은 것입니다.
이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제됩니다.<br />
단, 메모리에서 언제 해제될지는 예측할 수 없습니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>가비지 콜렉터</strong><br />
가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말합니다.<br />
더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미합니다.<br />
자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지합니다.</p>
</blockquote>

<p><br /></p>

<blockquote>
  <p><strong>언매니지드 언어와 매니지드 언어</strong><br />
프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류할 수 있습니다.<br />
C언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free() 같은 저수준 메모리 제어 기능을 제공합니다.<br />
언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 그 반대의 경우 치명적 오류를 생산할 가능성도 있습니다.
자바스크립트 같은 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않습니다.<br />
즉, 개발자가 명시적으로 메모리를 할당하고 해제할 수 없습니다.<br />
더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며, 이 또한 개발자가 관여할 수 없습니다.<br />
매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산성을 확보할 수 있다는 장점이 있지만 성능 면에서 어느 정도의 손실은 감수할 수 밖에 없습니다.</p>
</blockquote>

<p><br /></p>

<h2 id="7-식별자-네이밍-규칙">7. 식별자 네이밍 규칙</h2>

<p>식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유의 이름을 말합니다.<br />
식별자는 다음과 같은 네이밍 규칙을 준수해야 합니다.</p>

<ul>
  <li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있습니다.</li>
  <li>단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 합니다. 숫자로 시작하는 것은 허용하지 않습니다.</li>
  <li>예약어는 식별자로 사용할 수 없습니다.</li>
</ul>

<p><br /></p>

<p>변수 이름도 식별자이므로 위 네이밍 규칙을 따라야 합니다.</p>

<p>자바스크립트는 대소문자를 구별하므로 다음 변수는 각각 별개의 변수입니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">var</span> <span class="nx">firstname</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">firstName</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">FIRSTNAME</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙입니다.<br />
네이밍 컨벤션을 잘 지키면 읽기 좋은 이름을 만들 수 있습니다.<br />
다음과 같은 4가지 유형의 네이밍 컨벤션이 자주 사용됩니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 카멜 케이스(camelCase)</span>
<span class="kd">var</span> <span class="nx">firstName</span><span class="p">;</span>

<span class="c1">// 스네이크 케이스(snake_case)</span>
<span class="kd">var</span> <span class="nx">first_name</span><span class="p">;</span>

<span class="c1">// 파스칼 케이스(PascalCase)</span>
<span class="kd">var</span> <span class="nx">FirstName</span><span class="p">;</span>

<span class="c1">// 헝가리언 케이스(tpyeHungarianCase)</span>
<span class="kd">var</span> <span class="nx">strFirstName</span><span class="p">;</span> <span class="c1">// type + identifier</span>
<span class="kd">var</span> <span class="nx">$elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">myId</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// DOM 노드</span>
<span class="kd">var</span> <span class="nx">observable$</span> <span class="o">=</span> <span class="nx">fromEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// RxJS 옵저버블</span>
</code></pre></div></div>

<p><br /></p>

<p>일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지만 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용합니다.<br />
ECMAScript 사양에 정의되어 있는 객체와 함수들도 카멜 케이스와 파스칼 케이스를 사용하고 있습니다.<br />
따라서 코드 전체의 가독성을 높이려면 카멜 케이스와 파스칼 케이스를 따르는 것이 유리합니다.</p>

<p><br />
<br />
<br /></p>
:ET