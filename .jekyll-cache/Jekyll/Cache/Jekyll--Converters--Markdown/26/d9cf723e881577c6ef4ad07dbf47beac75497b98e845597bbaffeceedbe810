I"<p><br /></p>

<h1 id="프로토타입">프로토타입</h1>

<p>자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍(OOP)을 지원하는 멀티 패러다임 프로그래밍 언어입니다.</p>

<p>간혹 C++나 자바 같은 클래스 기반 객체지향 프로그래밍 언어의 특징은 클래스와 상속, 캡슐화를 위한 키워드인 <code class="language-html highlighter-rouge">public</code>, <code class="language-html highlighter-rouge">private</code>, <code class="language-html highlighter-rouge">protected</code> 등이 없어서 자바스크립트는 객체지향 언어가 아니라고 오해하는 경우도 있습니다.<br />
하지만 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 언어입니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>클래스(class)</strong><br />
ES6에서 클래스가 도입되었습니다.<br />
하지만 ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새로운 객체지향 모델을 제공하는 것은 아닙니다.<br />
사실 클래스도 함수이며, 기존 프로토타입 기반 패턴의 문법적 설탕(syntactic sugar)이라고 볼 수 있습니다.<br />
클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않습니다.<br />
클래스는 생성자 함수보다 엄격하며 클래스는 생성자 함수에서는 제공하지 않는 기능도 제공합니다.<br />
따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕으로 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다고 할 수 있습니다.</p>
</blockquote>

<p><br /></p>

<p>자바스크립트는 객체 기반의 프로그래밍 언어이며 <strong>자바스크립트를 이루고 있는 거의 “모든 것”이 객체</strong> 입니다.<br />
원시 타이(primitive type)의 값을 제외한 나머지 값들(함수, 배열, 정규 표현식 등)은 모두 객체입니다.</p>

<p>먼저 객체지향 프로그래밍에 대해 간단히 살펴봅시다.</p>

<p><br /></p>

<h2 id="1-객체지향-프로그래밍">1. 객체지향 프로그래밍</h2>

<p>객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(imperative programming)의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말합니다.</p>

<p>객체지향 프로그래밍은 실세계의 실체(사물이나 개념)을 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작합니다.<br />
실체는 특징이나 성질을 나타내는 <strong>속성(attribute/property)</strong> 을 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있습니다.</p>

<p>예를 들어, 사람은 이름, 주소, 성별, 나이, 신장, 체중, 학력, 성격, 직업 등 다양한 속성을 갖습니다.<br />
이때 “이름이 아무개이고 성별은 여성이며 나이는 20세인 사람”과 같이 속성을 구체적으로 표현하면 특정한 사람을 다른 사람과 구별하여 인식할 수 있습니다.</p>

<p>이러한 방식을 프로그래밍에 접목시켜봅시다.<br />
사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 “이름”과 “주소”라는 속성에만 관심이 있다고 가정합시다.<br />
이처럼 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 <strong>추상화(abstraction)</strong> 라 합니다.</p>

<p>“이름”과 “주소”라는 속성을 갖는 person이라는 객체를 자바스크립트로 표현하면 다음과 같습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 이름과 주소 속성을 갖는 객체</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span> <span class="c1">// {name: "Lee", address: "Seoul"}</span>
</code></pre></div></div>

<p><br /></p>

<p>이때 프로그래머(subject, 주체)는 이름과 주소 속성으로 표현된 객체(object)인 person을 다른 객체와 구별하여 인식할 수 있습니다.<br />
이처럼 <strong>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체</strong> 라 하며, 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임입니다.</p>

<p>이번에는 원(Circle)이라는 개념을 객체로 만들어봅시다.<br />
원에는 반지름이라는 속성이 있습니다.<br />
이 반지름을 가지고 원의 지름, 둘레, 넓이를 구할 수 있습니다.</p>

<p>이때 반지름은 원의 <strong>상태를 나타내는 데이터</strong> 이며 원의 지름, 둘레, 넓이를 구하는 것은 <strong>동작</strong> 입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="c1">// 반지름</span>

  <span class="c1">// 원의 지름: 2r</span>
  <span class="nx">getDiameter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="c1">// 원의 둘레: 2πr</span>
  <span class="nx">getPerimeter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="c1">// 원의 넓이: πrr</span>
  <span class="nx">getArea</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">);</span>
<span class="c1">// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getDiameter</span><span class="p">());</span> <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getPerimeter</span><span class="p">());</span> <span class="c1">// 31.41592653589793</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 78.53981633974483</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 객체지향 프로그래밍은 객체의 <strong>상태(state)</strong> 를 나타내는 데이터와 상태 데이터를 조작할 수 있는 <strong>동작 (behavior)</strong> 을 하나의 논리적인 단위로 묶어 생각합니다.<br />
따라서 객체는 <strong>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조</strong> 라고 할 수 있습니다.</p>

<p>이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부릅니다.</p>

<p>각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성(relationship)을 가질 수 있습니다.<br />
다른 객체와 메시지를 주고받거나 데이터를 처리할 수도 있습니다.<br />
또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 합니다.</p>

<p><br /><br /></p>

<h2 id="2-상속과-프로토-타입">2. 상속과 프로토 타입</h2>

<p>상속(inheritance)은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말합니다.</p>

<p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거합니다.<br />
중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것입니다.<br />
코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있으므로 매우 중요합니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Math.PI는 원주율을 나타내는 상수다.</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 반지름이 1인 인스턴스 생성</span>
<span class="kd">const</span> <span class="nx">circle1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// 반지름이 2인 인스턴스 생성</span>
<span class="kd">const</span> <span class="nx">circle2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는</span>
<span class="c1">// getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span>
<span class="c1">// getArea 메서드는 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle1</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">===</span> <span class="nx">circle2</span><span class="p">.</span><span class="nx">getArea</span><span class="p">);</span> <span class="c1">// false</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle1</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 3.141592653589793</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle2</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 12.566370614359172</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수는 동일한 프로퍼티(메서드 포함) 구조를 갖는 객체를 여러 개 생성할 때 유용합니다.<br />
하지만 위 예제의 생성자 함수는 문제가 있습니다.</p>

<p><code class="language-html highlighter-rouge">Circle</code> 생성자 함수가 생성하는 모든 객체(인스턴스)는 <code class="language-html highlighter-rouge">radius</code> 프로퍼티와 <code class="language-html highlighter-rouge">getArea</code> 메서드를 갖습니다.<br />
<code class="language-html highlighter-rouge">radius</code> 프로퍼티 값은 일반적으로 인스턴스마다 다릅니다(같은 상태를 갖는 여러 개의 인스턴스가 필요하다면 <code class="language-html highlighter-rouge">radius</code> 프로퍼티 값이 같을 수도 있습니다).<br />
하지만 <code class="language-html highlighter-rouge">getArea</code> 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직합니다.<br />
그런데 <code class="language-html highlighter-rouge">Circle</code> 생성자 함수는 인스턴스를 생성할 때마다 <code class="language-html highlighter-rouge">getArea</code> 메서드를 중복 생성하고 모든 인스턴스가 중복 소유합니다.</p>

<p>이처럼 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비합니다.<br />
또한 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 줍니다.<br />
만약 10개의 인스턴스를 생성하면 내용이 동일한 메서드도 10개 생성됩니다.</p>

<p>상속을 통해 불필요한 중복을 제거해 봅시다.<br />
<strong>자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현합니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를</span>
<span class="c1">// 공유해서 사용할 수 있도록 프로토타입에 추가한다.</span>
<span class="c1">// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.</span>
<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 인스턴스 생성</span>
<span class="kd">const</span> <span class="nx">circle1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">circle2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span>
<span class="c1">// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.</span>
<span class="c1">// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle1</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">===</span> <span class="nx">circle2</span><span class="p">.</span><span class="nx">getArea</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle1</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 3.141592653589793</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">circle2</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 12.566370614359172</span>
</code></pre></div></div>

<p><br /></p>

<p>Circle 생성자 함수가 생성한 모든 인스턴스를 자신의 프로토타입, 즉 상위(부모) 객체 역할을 하는 <code class="language-html highlighter-rouge">Circle.prototype</code>의 모든 프로퍼티와 메서드를 상속받습니다.</p>

<p><code class="language-html highlighter-rouge">getArea</code> 메서드는 단 하나만 생성되어 프로토타입인 <code class="language-html highlighter-rouge">Circle.prototype</code>의 메서드로 할당되어 있습니다.<br />
따라서 <code class="language-html highlighter-rouge">Circle</code> 생성자 함수가 생성하는 모든 인스턴스는 <code class="language-html highlighter-rouge">getArea</code> 메서드를 상속받아 사용할 수 있습니다.<br />
즉, 자신의 상태를 나타내는 <code class="language-html highlighter-rouge">radius</code> 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용하는 것입니다.</p>

<p>상속은 코드의 재사용이란 관점에서 매우 유용합니다.<br />
생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h2 id="3-프로토타입-객체">3. 프로토타입 객체</h2>

<p>프로토타입 객체(또는 줄여서 프로토타입)란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속(inheritance)을 구현하기 위해 사용됩니다.<br />
프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공합니다.<br />
프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있습니다.</p>

<p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조(null인 경우도 있습니다)입니다.<br />
[[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정됩니다.</p>

<p><strong>즉, 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장됩니다.</strong></p>

<p>예를 들어, 객체 리터럴에 의해 생성된 객체의 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>이고,<br />
생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩되어 있는 객체입니다.</p>

<p>모든 객체는 하나의 프로토타입을 갖습니다.<br />
그리고 모든 프로토타입은 생성자 함수와 연결되어 있습니다.</p>

<p>[[Prototype]] 내부 슬롯에는 직접 접근할 수 없지만, <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있습니다.<br />
그리고 프로토타입은 자신의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티를 통해 프로토타입에 접근할 수 있습니다.</p>

<p><br /></p>

<h3 id="31-__proto__-접근자-프로퍼티">3.1 __proto__ 접근자 프로퍼티</h3>

<p><strong>모든 객체는 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있습니다.</strong></p>

<h4 id="__proto__는-접근자-프로퍼티입니다">__proto__는 접근자 프로퍼티입니다.</h4>

<p>내부 슬롯은 프로퍼티가 아닙니다.<br />
따라서 자바스크립트는 원칙적으로 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않습니다.<br />
단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 합니다.</p>

<p>[[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있습니다.</p>

<p>접근자 프로퍼티는 자체적으로는 값([[Value]] 프로퍼티 어트리뷰트)을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function),<br />
즉 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티입니다.</p>

<p>Object.prototype의 접근자 프로퍼티인 <code class="language-html highlighter-rouge">__proto__</code>는 getter/setter 함수라고 부르는 접근자 함수([[Get]], [[Set]] 프로퍼티 어트리뷰트에 할당된 함수)를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당합니다.</p>

<p><code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티인 getter 함수인 [[Get]]이 호출됩니다.<br />
<code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티의 setter 함수인 [[Set]]이 호출됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="c1">// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">;</span>
<span class="c1">// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="__proto__-접근자-프로퍼티는-상속을-통해-사용됩니다">__proto__ 접근자 프로퍼티는 상속을 통해 사용됩니다.</h4>

<p><code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 <code class="language-html highlighter-rouge">Object.prototype</code>의 프로퍼티입니다.<br />
모든 객체는 상속을 통해 <code class="language-html highlighter-rouge">Object.prototype.__proto__</code> 접근자 프로퍼티를 사용할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span> <span class="p">};</span>

<span class="c1">// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">__proto__</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>

<span class="c1">// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="dl">"</span><span class="s2">__proto__</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// {get: ƒ, set: ƒ, enumerable: false, configurable: true}</span>

<span class="c1">// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">({}.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p><strong>Object.prototype</strong><br />
모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있습니다.<br />
자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색합니다.<br />
프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>이며, 이 객체의 프로퍼티와 메서드는 모든 객체에 상속됩니다.</p>
</blockquote>

<p><br /></p>

<h4 id="__proto__-접근자-프로퍼티를-통해-프로토타입에-접근하는-이유">__proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</h4>

<p>[[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">child</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// child의 프로토타입을 parent로 설정</span>
<span class="nx">child</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
<span class="c1">// parent의 프로토타입을 child로 설정</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">child</span><span class="p">;</span> <span class="c1">// TypeError: Cyclic __proto__ value</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제에서는 <code class="language-html highlighter-rouge">parent</code> 객체를 <code class="language-html highlighter-rouge">child</code> 객체의 프로토타입으로 설정한 후, <code class="language-html highlighter-rouge">child</code> 객체를 <code class="language-html highlighter-rouge">parent</code> 객체의 프로토타입으로 설정했습니다.<br />
이러한 코드가 에러없이 정상적으로 처리되면 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 만들어지기 때문에 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티는 에러를 발생시킵니다.</p>

<p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 합니다.<br />
즉, 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 합니다.<br />
하지만 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인, 다시 말해 순환 참조(circular reference)하는 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한 루프에 빠집니다.<br />
따라서 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있습니다.</p>

<p><br /></p>

<h4 id="__proto__-접근자-프로퍼티를-코드-내에서-직접-사용하는-것은-권장하지-않습니다">__proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않습니다.</h4>

<p><code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티는 ES5까지 ECMAScript 사양에 포함되지 않은 비표준이었습니다.<br />
하지만 일부 브라우저에서 <code class="language-html highlighter-rouge">__proto__</code>를 지원하고 있었기 때문에 브라우저 호환성을 고려하여 ES6에서 <code class="language-html highlighter-rouge">__proto__</code>를 표준으로 채택했습니다.<br />
현재 대부분의 브라우저(IE 11 이상)가 <code class="language-html highlighter-rouge">__proto__</code>를 지원합니다.</p>

<p>하지만 코드 내에서 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 직접 사용하는 것은 권장하지 않습니다.<br />
모든 객체가 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문입니다.<br />
직접 상속을 통해 다음과 같이 <code class="language-html highlighter-rouge">Object.prototype</code>을 상속받지 않는 객체를 생성할 수도 있기 때문에 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 사용할 수 없는 경우가 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="c1">// obj는 Object.__proto__를 상속받을 수 없다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="c1">// 따라서 Object.getPrototypeOf 메서드를 사용하는 편이 좋다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// null</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우에는 <code class="language-html highlighter-rouge">Object.getPrototypeOf</code> 메서드를 사용하고,<br />
프로토타입을 교체하고 싶은 경우에는 <code class="language-html highlighter-rouge">Object.setPrototypeOf</code> 메서드를 사용할 것을 권장합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="c1">// obj 객체의 프로토타입을 취득</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// obj.__proto__;</span>
<span class="c1">// obj 객체의 프로토타입을 교체</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">parent</span><span class="p">);</span> <span class="c1">// obj.__proto__ = parent;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Object.getPrototypeOf</code> 메서드와 <code class="language-html highlighter-rouge">Object.setPrototypeOf</code> 메서드는 <code class="language-html highlighter-rouge">get Object.prototype.__proto__</code>와 <code class="language-html highlighter-rouge">set Object.prototype.__proto__</code>의 처리 내용과 정확히 일치합니다.<br />
<code class="language-html highlighter-rouge">Object.getPrototypeOf</code> 메서드는 ES5에서 도입된 메서드이며, IE9 이상에서 지원합니다.<br />
<code class="language-html highlighter-rouge">Object.setPrototypeOf</code> 메서드는 ES6에서 도입된 메서드이며, IE11 이상에서 지원합니다.</p>

<p><br /></p>

<h3 id="32-함수-객체의-prototype-프로퍼티">3.2 함수 객체의 prototype 프로퍼티</h3>

<p><strong>함수 객체만이 소유하는 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킵니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 함수 객체는 prototype 프로퍼티를 소유한다.</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{}.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// -&gt; true</span>

<span class="c1">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span>
<span class="p">({}.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// -&gt; false</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">prototype</code> 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킵니다.<br />
따라서 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor인 화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드는 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 화살표 함수는 non-constructor다.</span>
<span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// non-constructor는 prototype 프로퍼티를 소유하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>

<span class="c1">// non-constructor는 프로토타입을 생성하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="c1">// ES6의 메서드 축약 표현으로 정의한 메서드는 non-constructor다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{},</span>
<span class="p">};</span>

<span class="c1">// non-constructor는 prototype 프로퍼티를 소유하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">prototype</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>

<span class="c1">// non-constructor는 프로토타입을 생성하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수로 호출하기 위해 정의하지 않은 일반 함수(함수 선언문, 함수 표현식)도 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티는 아무런 의미가 없습니다.</p>

<p><strong>모든 객체가 가지고 있는(엄밀히 말하면 <code class="language-html highlighter-rouge">Object.prototype</code>으로부터 상속받은) <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티와 함수 객체만이 가지고 있는 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티는 결국 동일한 프로토타입을 가리킵니다.</strong><br />
하지만 이들 프로퍼티를 사용하는 주체가 다릅니다.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>소유</th>
      <th>값</th>
      <th>사용 주체</th>
      <th>사용 목적</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티</td>
      <td>모든 객체</td>
      <td>프로토타입의 참조</td>
      <td>모든 객체</td>
      <td>객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용</td>
    </tr>
    <tr>
      <td><code class="language-html highlighter-rouge">prototype</code> 프로퍼티</td>
      <td><code class="language-html highlighter-rouge">constructor</code></td>
      <td>프로토타입의 참조</td>
      <td>생성자 함수</td>
      <td>생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>예를 들어, 생성자 함수로 객체를 생성한 후, <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티와 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티로 프로토타입 객체에 접근해봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 결국 Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">me</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="33-프로토타입의-constructor-프로퍼티와-생성자-함수">3.3 프로토타입의 constructor 프로퍼티와 생성자 함수</h3>

<p>모든 프로토타입은 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티를 갖습니다.<br />
이 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티는 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킵니다.<br />
이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄집니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// me 객체의 생성자 함수는 Person이다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제에서 <code class="language-html highlighter-rouge">Person</code> 생성자 함수는 <code class="language-html highlighter-rouge">me</code> 객체를 생성했습니다.<br />
이때 <code class="language-html highlighter-rouge">me</code> 객체는 프로토타입의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티를 통해 생성자 함수와 연결됩니다.<br />
<code class="language-html highlighter-rouge">me</code> 객체에는 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티가 없지만 <code class="language-html highlighter-rouge">me</code> 객체의 프로토타입인 <code class="language-html highlighter-rouge">Person.prototype</code>에는 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티가 있습니다.<br />
따라서 <code class="language-html highlighter-rouge">me</code> 객체는 프로토타입인 <code class="language-html highlighter-rouge">Person.prototype</code>의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티를 상속받아 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수의-프로토타입">4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수의 프로토타입</h2>

<p>앞에서 살펴본 바와 같이 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티에 의해 생성자 함수와 연결됩니다.<br />
이때 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// obj 객체를 생성한 생성자 함수는 Object다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// add 함수 객체를 생성한 생성자 함수는 Function이다.</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">return a + b</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// me 객체를 생성한 생성자 함수는 Person이다.</span>
<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>하지만 리터럴 표기법에 의한 객체 생성 방식과 같이 명시적으로 <code class="language-html highlighter-rouge">new</code> 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성 방식도 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 객체 리터럴</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 함수 리터럴</span>
<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 배열 리터럴</span>
<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="c1">// 정규표현식 리터럴</span>
<span class="kd">const</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/is/gi</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재합니다.<br />
하지만 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 하지만 obj 객체의 생성자 함수는 Object 생성자 함수다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제의 <code class="language-html highlighter-rouge">obj</code> 객체는 <code class="language-html highlighter-rouge">Object</code> 생성자 함수로 생성한 객체가 아니라 객체 리터럴에 의해 생성된 객체입니다.<br />
하지만 <code class="language-html highlighter-rouge">obj</code> 객체는 <code class="language-html highlighter-rouge">Object</code> 생성자 함수와 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티로 연결되어 있습니다.<br />
그렇다면 객체 리터럴에 의해 생성된 객체는 사실 <code class="language-html highlighter-rouge">Object</code> 생성자 함수로 생성되는 것은 아닐까요?</p>

<p>ECMAScript 사양을 살펴봅시다.<br />
<code class="language-html highlighter-rouge">Object</code> 생성자 함수는 다음과 같이 구현하도록 정의되어 있습니다.</p>

<p><br /></p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">20.</span>1.1.1 Object ( [ value ] )
When the Object function is called with optional argument value, the following steps are taken:
<span class="p">
1.</span> If NewTarget is neither undefined nor the active function, then
   a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%").
<span class="p">2.</span> If value is undefined or null, return ! OrdinaryObjectCreate(%Object.prototype%).
<span class="p">3.</span> Return ! ToObject(value).
   The "length" property of the Object function is 1𝔽.
</code></pre></div></div>

<p><br /></p>

<p>2에서 <code class="language-html highlighter-rouge">Object</code> 생성자 함수에 인수를 전달하지 않거나 <code class="language-html highlighter-rouge">undefined</code> 또는 <code class="language-html highlighter-rouge">null</code>을 인수로 전달하면서 호출하면 내부적으로는 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>를 호출하여 <code class="language-html highlighter-rouge">Object.prototype</code>을 프로토타입으로 갖는 빈 객체를 생성합니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>추상 연산(abract operation)</strong><br />
추상 연산은 ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것입니다.<br />
ECMAScript 사양에서 설명을 위해 사용되는 함수와 유사한 의사 코드라고 이해합시다.</p>
</blockquote>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 2. Object 생성자 함수에 의한 객체 생성</span>
<span class="c1">// Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.</span>
<span class="c1">// 인수가 전달되지 않았을 때 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다.</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// {}</span>

<span class="c1">// 1. new.target이 undefined나 Object가 아닌 경우</span>
<span class="c1">// 인스턴스 -&gt; Foo.prototype -&gt; Object.prototype 순으로 프로토타입 체인이 생성된다.</span>
<span class="kd">class</span> <span class="nx">Foo</span> <span class="kd">extends</span> <span class="nb">Object</span> <span class="p">{}</span>
<span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span> <span class="c1">// Foo {}</span>

<span class="c1">// 3. 인수가 전달된 경우에는 인수를 객체로 변환한다.</span>
<span class="c1">// Number 객체 생성</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// Number {123}</span>

<span class="c1">// String  객체 생성</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">(</span><span class="dl">"</span><span class="s2">123</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// String {"123"}</span>
</code></pre></div></div>

<p><br /></p>

<p>객체 리터럴이 평가될 때는 다음과 같이 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>를 호출하여 빈 객체를 생성하고 프로퍼티를 추가하도록 정의되어 있습니다.</p>

<p><br /></p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">13.</span>2.6.4 Runtime Semantics: Evaluation
ObjectLiteral : { }
<span class="p">
1.</span> Return ! OrdinaryObjectCreate(%Object.prototype%).
   ObjectLiteral :
   { PropertyDefinitionList }
   { PropertyDefinitionList , }
<span class="p">1.</span> Let obj be ! OrdinaryObjectCreate(%Object.prototype%).
<span class="p">1.</span> Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.
<span class="p">1.</span> Return obj.
</code></pre></div></div>

<p><br /></p>

<p>이처럼 <code class="language-html highlighter-rouge">Object</code> 생성자 함수 호출과 객체 리터럴의 평가는 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>를 호출하여 빈 객체를 생성하는 점에서 동일하나 <code class="language-html highlighter-rouge">new.target</code>의 확인이나 프로퍼티를 추가하는 처리 등 세부 내용은 다릅니다.<br />
따라서 객체 리터럴에 의해 생성된 객체는 <code class="language-html highlighter-rouge">Object</code> 생성자 함수가 생성한 객체가 아닙니다.</p>

<p>함수 객체의 경우 차이가 더 명확합니다.<br />
<code class="language-html highlighter-rouge">Function</code> 생성자 함수를 호출하여 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성하며 클로저도 만들지 않습니다.<br />
따라서 함수 선언문과 함수 표현식을 평가하여 함수 객체를 생성한 것은 <code class="language-html highlighter-rouge">Function</code> 생성자 함수가 아닙니다.<br />
하지만 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티를 통해 확인해보면 <code class="language-html highlighter-rouge">foo</code> 함수의 생성자 함수는 <code class="language-html highlighter-rouge">Function</code> 생성자 함수입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// foo 함수는 Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성했다.</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// 하지만 constructor 프로퍼티를 통해 확인해보면 함수 foo의 생성자 함수는 Function 생성자 함수다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요합니다.<br />
따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖습니다.<br />
프로토타입은 생성자 함수와 더불어 생성되며 <code class="language-html highlighter-rouge">prototype</code>, <code class="language-html highlighter-rouge">contructor</code> 프로퍼티에 의해 연결되어 있기 때문입니다.</p>

<p>다시 말해, <strong>프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재합니다.</strong></p>

<p>리터럴 표기법(객체 리터럴, 함수 리터럴, 배열 리터럴, 정규 표현식 리터럴 등)에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아닙니다.<br />
하지만 큰 틀에서 생각해 보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없습니다.</p>

<p>예를 들어, 객체 리터럴에 의해 생성한 객체와 <code class="language-html highlighter-rouge">Object</code> 생성자 함수에 의해 생성한 객체는 생성 과정에 미묘한 차이는 있지만 결국 객체로서 동일한 특성을 갖습니다.<br />
함수 리터럴에 의해 생성한 함수와 <code class="language-html highlighter-rouge">Function</code> 생성자 함수에 의해 생성한 함수는 생성 과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖습니다.</p>

<p>따라서 프로토타입의 <code class="language-html highlighter-rouge">contructor</code> 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없습니다.<br />
리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 다음과 같습니다.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>리터럴 표기법</th>
      <th>생성자 함수</th>
      <th>프로토타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>객체 리터럴</td>
      <td><code class="language-html highlighter-rouge">Object</code></td>
      <td><code class="language-html highlighter-rouge">Object.prototype</code></td>
    </tr>
    <tr>
      <td>함수 리터럴</td>
      <td><code class="language-html highlighter-rouge">Function</code></td>
      <td><code class="language-html highlighter-rouge">Function.prototype</code></td>
    </tr>
    <tr>
      <td>배열 리터럴</td>
      <td><code class="language-html highlighter-rouge">Array</code></td>
      <td><code class="language-html highlighter-rouge">Array.prototype</code></td>
    </tr>
    <tr>
      <td>정규 표현식 리터럴</td>
      <td><code class="language-html highlighter-rouge">RegExp</code></td>
      <td><code class="language-html highlighter-rouge">RegExp.prototype</code></td>
    </tr>
  </tbody>
</table>

<p><br /><br /></p>

<h2 id="5-프로토타입의-생성-시점">5. 프로토타입의 생성 시점</h2>

<p>리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결되는 것을 살펴보았습니다.<br />
객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있습니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>Object.create 메서드와 클래스에 의한 객체 생성</strong><br />
Object.create 메서드와 클래스로 객체를 생성하는 방법도 있습니다.<br />
Object.create 메서드와 클래스로 생성한 객체도 생성자 함수와 연결되어 있습니다.</p>
</blockquote>

<p><br /></p>

<p><strong>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성됩니다.</strong><br />
프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문입니다.</p>

<p>생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있습니다.<br />
사용자 정의 생성자 함수와 빌트인 생성자 함수를 구분하여 프로토타입 생성 시점에 대해 살펴봅시다.</p>

<p><br /></p>

<h3 id="51-사용자-정의-생성자-함수와-프로토타입-생성-시점">5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점</h3>

<p>내부 메서드 [[Contruct]]를 갖는 함수 객체, 즉 화살표 함수나 ES6의 메서드 축약 표현으로 정의하지 않고 일반 함수(함수 선언문, 함수 표현식)로 정의한 함수 객체는 <code class="language-html highlighter-rouge">new</code> 연산자와 함께 생성자 함수로서 호출할 수 있습니다.</p>

<p><strong>생성자 함수로서 호출할 수 있는 함수, 즉 <code class="language-html highlighter-rouge">consturctor</code>는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성됩니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// {constructor: ƒ}</span>

<span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 화살표 함수는 non-constructor다.</span>
<span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// non-constructor는 프로토타입이 생성되지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p><br /></p>

<p>함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행됩니다.<br />
따라서 함수 선언문으로 정의된 <code class="language-html highlighter-rouge">Person</code> 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 됩니다.<br />
이때 프로토타입도 더불어 생성됩니다.<br />
생성된 프로토타입은 <code class="language-html highlighter-rouge">Person</code> 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩됩니다.</p>

<p><code class="language-html highlighter-rouge">Person</code> 생성자 함수와 더불어 생성된 프로토타입의 내부를 살펴봅시다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span><span class="nl">constructor</span><span class="p">:</span> <span class="nx">ƒ</span><span class="p">}</span>
 <span class="nl">constructor</span><span class="p">:</span> <span class="nx">ƒ</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
 <span class="p">[[</span><span class="nx">Prototype</span><span class="p">]]:</span> <span class="nb">Object</span>
</code></pre></div></div>

<p>생성된 프로토타입은 오직 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티만을 갖는 객체입니다.<br />
프로토타입도 객체이고 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 갖습니다.<br />
생성된 프로토타입의 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.</p>

<p>이처럼 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며, 생성된 프로토타입의 프로토타입은 언제나 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.</p>

<p><br /></p>

<h3 id="52-빌트인-생성자-함수와-프로토타입-생성-시점">5.2 빌트인 생성자 함수와 프로토타입 생성 시점</h3>

<p><code class="language-html highlighter-rouge">Object</code>, <code class="language-html highlighter-rouge">String</code>, <code class="language-html highlighter-rouge">Number</code>, <code class="language-html highlighter-rouge">Function</code>, <code class="language-html highlighter-rouge">Array</code>, <code class="language-html highlighter-rouge">RegExp</code>, <code class="language-html highlighter-rouge">Date</code>, <code class="language-html highlighter-rouge">Promise</code> 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됩니다.<br />
모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성됩니다.<br />
생성된 프로토타입은 빌트인 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩됩니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>전역 객체(global object)</strong><br />
전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체입니다.<br />
전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미합니다.<br />
전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array…)들과 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖습니다.<br />
Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수입니다.</p>
</blockquote>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 전역 객체 window는 브라우저에 종속적이므로 아래 코드는 브라우저 환경에서 실행해야 한다.</span>
<span class="c1">// 빌트인 객체인 Object는 전역 객체 window의 프로퍼티다.</span>
<span class="nb">window</span><span class="p">.</span><span class="nb">Object</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p>표준 빌트인 객체인 Object도 전역 객체의 프로퍼티이며, 전역 객체가 생성되는 시점에 생성됩니다.</p>
</blockquote>

<p><br /></p>

<p>이처럼 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재합니다.<br />
<strong>이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당됩니다.</strong><br />
이로써 생성된 객체는 프로토타입을 상속받습니다.</p>

<p><br /><br /></p>

<h2 id="6-객체-생성-방식과-프로토타입의-결정">6. 객체 생성 방식과 프로토타입의 결정</h2>

<p>객체는 다음과 같이 다양한 생성 방법이 있습니다.</p>

<ul>
  <li>객체 리터럴</li>
  <li><code class="language-html highlighter-rouge">Object</code> 생성자 함수</li>
  <li>생성자 함수</li>
  <li><code class="language-html highlighter-rouge">Object.create</code> 메서드</li>
  <li>클래스(ES6)</li>
</ul>

<p><br /></p>

<p>이처럼 다양한 방식으로 생성된 모든 객체는 각 방식마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 의해 생성된다는 공통점이 있습니다.</p>

<p>추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받습니다.<br />
그리고 자신이 생성할 객체에 추가할 프로퍼티 목록을 옵션으로 전달할 수 있습니다.<br />
추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우 프로퍼티를 객체에 추가합니다.<br />
그리고 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 다음, 생성한 객체를 반환합니다.</p>

<p>즉, 프로토타입은 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 전달되는 인수에 의해 결정됩니다.<br />
이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정됩니다.</p>

<p><br /></p>

<h3 id="61-객체-리터럴에-의해-생성된-객체의-프로토타입">6.1 객체 리터럴에 의해 생성된 객체의 프로토타입</h3>

<p>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>를 호출합니다.<br />
이때 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 전달되는 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.<br />
즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<p>위 객체 리터럴이 평가되면 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 의해 <code class="language-html highlighter-rouge">Object</code> 생성자 함수와 <code class="language-html highlighter-rouge">Object.prototype</code>과 생성된 객체 사이에 연결이 만들어집니다.</p>

<p>이처럼 객체 리터럴에 의해 생성된 <code class="language-html highlighter-rouge">obj</code> 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>을 프로토타입으로 갖게 되며, 이로써 <code class="language-html highlighter-rouge">Object.prototype</code>을 상속받습니다.<br />
<code class="language-html highlighter-rouge">obj</code> 객체는 <code class="language-html highlighter-rouge">constructor</code> 프로퍼티와 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드 등을 소유하지 않지만 자신의 프로토타입인 <code class="language-html highlighter-rouge">Object.prototype</code>의 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티와 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 자신의 자산인 것처럼 자유롭게 사용할 수 있습니다.<br />
이는 <code class="language-html highlighter-rouge">obj</code> 객체가 자신의 프로토타입인 <code class="language-html highlighter-rouge">Object.prototype</code> 객체를 상속받았기 때문입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="c1">// 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="62-object-생성자-함수에-의해-생성된-객체의-프로토타입">6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3>

<p><code class="language-html highlighter-rouge">Object</code> 생성자 함수를 인수 없이 호출하면 빈 객체가 생성됩니다.<br />
<code class="language-html highlighter-rouge">Object</code> 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>가 호출됩니다.<br />
이때 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 전달되는 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.<br />
즉, <code class="language-html highlighter-rouge">Object</code> 생성자 함수에 의해 생성되는 객체의 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>위 코드가 실행되면 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 의해 <code class="language-html highlighter-rouge">Object</code> 생성자 함수와 <code class="language-html highlighter-rouge">Object.prototype</code>과 생성된 객체 사이에 연결이 만들어집니다.<br />
객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖습니다.</p>

<p>이처럼 <code class="language-html highlighter-rouge">Object</code> 생성자 함수에 의해 생성된 <code class="language-html highlighter-rouge">obj</code> 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>을 프로토타입으로 갖게 되며, 이로써 <code class="language-html highlighter-rouge">Object.prototype</code>을 상속받습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Object 생성자 함수에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>객체 리터럴과 <code class="language-html highlighter-rouge">Object</code> 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있습니다.<br />
객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가하지만 <code class="language-html highlighter-rouge">Object</code> 생성자 함수 방식은 일단 빈 객체를 생성한 이후 프로퍼티를 추가해야 합니다.</p>

<p><br /></p>

<h3 id="63-생성자-함수에-의해-생성된-객체의-프로토타입">6.3 생성자 함수에 의해 생성된 객체의 프로토타입</h3>

<p><code class="language-html highlighter-rouge">new</code> 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 생성 방식과 마찬가지로 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>가 호출됩니다.<br />
이때 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 전달되는 프로토타입은 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩되어 있는 객체입니다.<br />
즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩되어 있는 객체입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>위 코드가 실행되면 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>에 의해 다음과 같이 생성자 함수와 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩되어 있는 객체와 생성된 객체 사이에 연결이 만들어집니다.</p>

<p>표준 빌트인 객체인 <code class="language-html highlighter-rouge">Object</code> 생성자 함수와 더불어 생성된 프로토타입 <code class="language-html highlighter-rouge">Object.prototype</code>은 다양한 빌트인 메서드(<code class="language-html highlighter-rouge">hasOwnProperty</code>, <code class="language-html highlighter-rouge">propertyIsEnumerable</code> 등)를 갖고 있습니다.<br />
하지만 사용자 정의 생성자 함수 Person과 더불어 생성된 프로토타입 Person.prototype의 프로퍼티는 constructor뿐입니다.</p>

<p>프로토타입 <code class="language-html highlighter-rouge">Person.prototype</code>에 프로퍼티를 추가하여 하위(자식) 객체가 상속받을 수 있도록 구현해봅시다.<br />
프로토타입은 객체입니다.<br />
따라서 일반 객체와 같이 프로토타입에도 프로퍼티를 추가/삭제할 수 있습니다.<br />
그리고 이렇게 추가/삭제된 프로퍼티는 프로퍼티 체인에 즉각 반영됩니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 프로토타입 메서드</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">you</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Lee</span>
<span class="nx">you</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Kim</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Person</code> 생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 <code class="language-html highlighter-rouge">sayHello</code> 메서드를 상속받아 자신의 메서드처럼 사용할 수 있습니다.</p>

<p><br /><br /></p>

<h2 id="7-프로토타입-체인">7. 프로토타입 체인</h2>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 프로토타입 메서드</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// hasOwnProperty는 Object.prototype의 메서드다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Person</code> 생성자 함수에 의해 생성된 <code class="language-html highlighter-rouge">me</code> 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>의 메서드인 <code class="language-html highlighter-rouge">hasOwnProperty</code>를 호출할 수 있습니다.<br />
이것은 <code class="language-html highlighter-rouge">me</code> 객체가 <code class="language-html highlighter-rouge">Person.prototype</code>뿐만 아니라 <code class="language-html highlighter-rouge">Object.prototype</code>도 상속받았다는 것을 의미합니다.<br />
<code class="language-html highlighter-rouge">me</code> 객체의 프로토타입은 <code class="language-html highlighter-rouge">Person.prototype</code>입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; true</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Person.prototype</code>의 프로토타입은 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.<br />
프로토타입의 프로토타입은 언제나 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// -&gt; true</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>자바스크립트는 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색합니다.</strong><br />
<strong>이를 프로토타입 체인이라 합니다.</strong><br />
<strong>프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘입니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// hasOwnProperty는 Object.prototype의 메서드다.</span>
<span class="c1">// me 객체는 프로토타입 체인을 따라 hasOwnProperty 메서드를 검색하여 사용한다.</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; true</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">me.hasOwnProperty('name')</code>과 같이 메서드를 호출하면 자바스크립트 엔진은 다음과 같은 과정을 거쳐 메서드를 검색합니다.<br />
물론 프로퍼티를 참조하는 경우도 마찬가지입니다.</p>

<ol>
  <li>먼저 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 호출한 <code class="language-html highlighter-rouge">me</code> 객체에서 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 검색합니다. <code class="language-html highlighter-rouge">me</code> 객체에는 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드가 없으므로 프로토타입 체인을 따라, 다시 말해 [[Prototype]] 내부 슬롯에 바인딩되어 있는 프로토타입(위 예제의 경우 <code class="language-html highlighter-rouge">Person.prototype</code>)으로 이동하여 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 검색합니다.</li>
  <li><code class="language-html highlighter-rouge">Person.prototype</code>에도 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드가 없으므로 프로토타입 체인을 따라, 다시 말해 [[Prototype]] 내부 슬롯에 바인딩되어 있는 프로토타입(위 예제의 경우 <code class="language-html highlighter-rouge">Object.prototype</code>)으로 이동하여 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 검색합니다.</li>
  <li><code class="language-html highlighter-rouge">Object.prototype</code>에는 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드가 존재합니다. 자바스크립트 엔진은 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드를 호출합니다. 이때 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드의 <code class="language-html highlighter-rouge">this</code>에는 <code class="language-html highlighter-rouge">me</code> 객체가 바인딩됩니다.</li>
</ol>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p><strong>call 메서드</strong><br />
call 메서드는 this로 사용할 객체를 전달하면서 함수를 호출합니다.</p>
</blockquote>

<p><br /></p>

<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 <code class="language-html highlighter-rouge">Object.prototype</code>입니다.<br />
따라서 모든 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>을 상속받습니다.<br />
<strong><code class="language-html highlighter-rouge">Object.prototype</code>을 프로토타입 체인의 종점(end of prototype chain)</strong> 이라 합니다.<br />
<code class="language-html highlighter-rouge">Object.prototype</code>의 프로토타입, 즉 [[Prototype]] 내부 슬롯의 값은 <code class="language-html highlighter-rouge">null</code>입니다.</p>

<p>프로토타입 체인의 종점인 <code class="language-html highlighter-rouge">Object.prototype</code>에서도 프로퍼티를 검색할 수 없는 경우 <code class="language-html highlighter-rouge">undefined</code>를 반환합니다.<br />
이때 에러가 발생하지 않는 것에 주의합시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 자바스크립트 엔진은 프로토타입 체인을 따라 프로퍼티/메서드를 검색합니다.<br />
다시 말해, 자바스크립트 엔진은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 객체의 프로퍼티를 검색합니다.<br />
따라서 <strong>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘</strong> 이라고 할 수 있습니다.</p>

<p>이에 반해, 프로퍼티가 아닌 식별자는 스코프 체인에서 검색합니다.<br />
다시 말해, 자바스크립트 엔진은 함수의 중첩 관계로 이루어진 스코프의 계층적 구조에서 식별자를 검색합니다.<br />
따라서 <strong>스코프 체인은 식별자 검색을 위한 메커니즘</strong> 이라고 할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">me</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제의 경우, 먼저 스코프 체인에서 <code class="language-html highlighter-rouge">me</code> 식별자를 검색합니다.<br />
<code class="language-html highlighter-rouge">me</code> 식별자는 전역에서 선언되었으므로 전역 스코프에서 검색됩니다.<br />
<code class="language-html highlighter-rouge">me</code> 식별자를 검색한 다음, <code class="language-html highlighter-rouge">me</code> 객체의 프로토타입 체인에서 <code class="language-html highlighter-rouge">hasOwnProperty</code> 메서드를 검색합니다.</p>

<p>이처럼 <strong>스코프 체인과 프로토타입 체인은 서로 연관없이 별도로 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용됩니다.</strong></p>

<p><br /><br /></p>

<h2 id="8-오버라이딩과-프로퍼티-섀도잉">8. 오버라이딩과 프로퍼티 섀도잉</h2>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 생성자 함수</span>
  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 프로토타입 메서드</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// 생성자 함수를 반환</span>
  <span class="k">return</span> <span class="nx">Person</span><span class="p">;</span>
<span class="p">})();</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 인스턴스 메서드</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hey! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hey! My name is Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수로 객체(인스턴스)를 생성한 다음, 인스턴스에 메서드를 추가했습니다.</p>

<p>프로토타입이 소유한 프로퍼티(메서드 포함)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부릅니다.</p>

<p>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가합니다.<br />
이때 인스턴스 메서드 <code class="language-html highlighter-rouge">sayHello</code>는 프로토타입 메서드 <code class="language-html highlighter-rouge">sayHello</code>를 오버라이딩했고 프로토타입 메서드 <code class="language-html highlighter-rouge">sayHello</code>는 가려집니다.<br />
이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 합니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>오버라이딩(overriding)</strong><br />
상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식입니다.</p>
</blockquote>

<p><br /></p>

<blockquote>
  <p><strong>오버로딩(overloading)</strong><br />
함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식입니다.<br />
자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있습니다.</p>
</blockquote>

<p><br /></p>

<p>프로퍼티를 삭제하는 경우도 마찬가지입니다.<br />
위 예제에서 추가한 인스턴스 메서드 <code class="language-html highlighter-rouge">sayHello</code>를 삭제해봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 인스턴스 메서드를 삭제한다.</span>
<span class="k">delete</span> <span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">;</span>
<span class="c1">// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>당연히 프로토타입 메서드가 아닌 인스턴스 메서드 <code class="language-html highlighter-rouge">sayHello</code>가 삭제됩니다.<br />
다시 한번 <code class="language-html highlighter-rouge">sayHello</code> 메서드를 삭제하여 프로토타입 메서드의 삭제를 시도해봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입 체인을 통해 프로토타입 메서드가 삭제되지 않는다.</span>
<span class="k">delete</span> <span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">;</span>
<span class="c1">// 프로토타입 메서드가 호출된다.</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>이와 같이 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능합니다.<br />
다시 말해 하위 객체를 통해 프로토타입에 <code class="language-html highlighter-rouge">get</code> 엑세스는 허용되나 <code class="language-html highlighter-rouge">set</code> 엑세스는 허용되지 않습니다.</p>

<p>프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근해야 합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입 메서드 변경</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hey! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hey! My name is Lee</span>

<span class="c1">// 프로토타입 메서드 삭제</span>
<span class="k">delete</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">;</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// TypeError: me.sayHello is not a function</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="9-프로토타입의-교체">9. 프로토타입의 교체</h2>

<p>프로토타입은 임의의 다른 객체로 변경할 수 있습니다.<br />
이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미합니다.<br />
이러한 특징을 활용하여 객체 간의 상속 관계를 동적으로 변경할 수 있습니다.<br />
프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있습니다.</p>

<p><br /></p>

<h3 id="91-생성자-함수에-의한-프로토타입의-교체">9.1 생성자 함수에 의한 프로토타입의 교체</h3>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">Person</span><span class="p">;</span>
<span class="p">})();</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<p>①에서 <code class="language-html highlighter-rouge">Person.prototype</code>에 객체 리터럴을 할당했습니다.<br />
이는 <code class="language-html highlighter-rouge">Person</code> 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것입니다.</p>

<p>프로토타입으로 교체한 객체 리터럴에는 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티가 없습니다.<br />
<code class="language-html highlighter-rouge">constructor</code> 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티입니다.<br />
따라서 <code class="language-html highlighter-rouge">me</code> 객체의 생성자 함수를 검색하면 <code class="language-html highlighter-rouge">Person</code>이 아닌 <code class="language-html highlighter-rouge">Object</code>가 나옵니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>
<span class="c1">// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 프로토타입을 교체하면 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티와 생성자 함수 간의 연결이 파괴됩니다.<br />
파괴된 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티와 생성자 함수 간의 연결을 되살려 봅시다.<br />
프로토타입으로 교체한 객체 리터럴에 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티를 추가하여 프로토타입의 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티를 되살립니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// constructor 프로퍼티와 생성자 함수 간의 연결을 설정</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="nx">Person</span><span class="p">,</span>
    <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">Person</span><span class="p">;</span>
<span class="p">})();</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// constructor 프로퍼티가 생성자 함수를 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="92-인스턴스에-의한-프로토타입의-교체">9.2 인스턴스에 의한 프로토타입의 교체</h3>

<p>프로토타입은 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티뿐만 아니라 인스턴스의 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티(또는 <code class="language-html highlighter-rouge">Object.getPrototypeOf</code> 메서드)를 통해 접근할 수 있습니다.<br />
따라서 인스턴스의 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티(또는 <code class="language-html highlighter-rouge">Object.setPrototypeOf</code> 메서드)를 통해 프로토타입을 교체할 수 있습니다.</p>

<p>생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것입니다.<br />
<code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것입니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 프로토타입으로 교체할 객체</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// ① me 객체의 프로토타입을 parent 객체로 교체한다.</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">parent</span><span class="p">);</span>
<span class="c1">// 위 코드는 아래의 코드와 동일하게 동작한다.</span>
<span class="c1">// me.__proto__ = parent;</span>

<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Lee</span>
</code></pre></div></div>

<p><br /></p>

<p>①에서 <code class="language-html highlighter-rouge">me</code> 객체의 프로토타입을 <code class="language-html highlighter-rouge">parent</code> 객체로 교체했습니다.<br />
프로토타입으로 교체한 객체에는 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티가 없으므로 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티와 생성자 함수 간의 연결이 파괴됩니다.<br />
따라서 프로토타입의 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티로 <code class="language-html highlighter-rouge">me</code> 객체의 생성자 함수를 검색하면 <code class="language-html highlighter-rouge">Person</code>이 아닌 <code class="language-html highlighter-rouge">Object</code>가 나옵니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>
<span class="c1">// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체는 별다른 차이가 없어 보입니다.<br />
하지만 미묘한 차이가 있습니다.<br />
생성자 함수에 의한 프로토타입 교체는 <code class="language-html highlighter-rouge">Person</code> 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티가 교체된 프로토타입을 가르킵니다.<br />
인스턴스에 의한 프로토타입 교체는 <code class="language-html highlighter-rouge">Person</code> 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티가 교체된 프로토타입을 가리키지 않습니다.</p>

<p>프로토타입으로 교체한 객체 리터럴에 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티를 추가하고 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티를 재설정하여 파괴된 생성자 함수와 프로토타입 간의 연결을 되살려 봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 프로토타입으로 교체할 객체</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// constructor 프로퍼티와 생성자 함수 간의 연결을 설정</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="nx">Person</span><span class="p">,</span>
  <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결을 설정</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>

<span class="c1">// me 객체의 프로토타입을 parent 객체로 교체한다.</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">parent</span><span class="p">);</span>
<span class="c1">// 위 코드는 아래의 코드와 동일하게 동작한다.</span>
<span class="c1">// me.__proto__ = parent;</span>

<span class="nx">me</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Hi! My name is Lee</span>

<span class="c1">// constructor 프로퍼티가 생성자 함수를 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// false</span>

<span class="c1">// 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭습니다.<br />
따라서 프로토타입은 직접 교체하지 않는 것이 좋습니다.<br />
상속 관계를 인위적으로 설정하려면 직접 상속이 더 편리하고 안전합니다.<br />
또는 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있습니다.</p>

<p><br /><br /></p>

<h2 id="10-instanceof-연산자">10. instanceof 연산자</h2>

<p><code class="language-html highlighter-rouge">instanceof</code> 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받습니다.<br />
만약 우변의 피연산자가 함수가 아닌 경우 <code class="language-html highlighter-rouge">TypeError</code>가 발생합니다.</p>

<p><br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">객체</span> <span class="k">instanceof</span> <span class="nx">생성자</span> <span class="nx">함수</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>우변의 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code>에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 <code class="language-html highlighter-rouge">true</code>로 평가되고, 그렇지 않은 경우에는 <code class="language-html highlighter-rouge">false</code>로 평가됩니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">instanceof</code> 연산자가 어떻게 동작하는지 이해하기 위해 프로토타입을 교체해 봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 프로토타입으로 교체할 객체</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 프로토타입의 교체</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">parent</span><span class="p">);</span>

<span class="c1">// Person 생성자 함수와 parent 객체는 연결되어 있지 않다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">parent</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>

<span class="c1">// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하지 않기 때문에 false로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>

<span class="c1">// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">me</code> 객체는 비록 프로토타입이 교체되어 프로토타입과 생성자 함수 간의 연결이 파괴되었지만 <code class="language-html highlighter-rouge">Person</code> 생성자 함수에 의해 생성된 인스턴스임에는 틀림이 없습니다.<br />
그러나 <code class="language-html highlighter-rouge">me instanceof Person</code>은 <code class="language-html highlighter-rouge">false</code>로 평가됩니다.</p>

<p>이는 <code class="language-html highlighter-rouge">Person.prototype</code>이 <code class="language-html highlighter-rouge">me</code> 객체의 프로토타입 체인 상에 존재하지 않기 때문입니다.<br />
따라서 프로토타입으로 교체한 <code class="language-html highlighter-rouge">parent</code> 객체를 <code class="language-html highlighter-rouge">Person</code> 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티에 바인딩하면 <code class="language-html highlighter-rouge">me instanceof Person</code>은 <code class="language-html highlighter-rouge">true</code>로 평가될 것입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 프로토타입으로 교체할 객체</span>
<span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 프로토타입의 교체</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">parent</span><span class="p">);</span>

<span class="c1">// Person 생성자 함수와 parent 객체는 연결되어 있지 않다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">parent</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>

<span class="c1">// parent 객체를 Person 생성자 함수의 prototype 프로퍼티에 바인딩한다.</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>

<span class="c1">// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 <code class="language-html highlighter-rouge">instanceof</code> 연산자는 프로토타입의 <code class="language-html highlighter-rouge">contructor</code> 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라 <strong>생성자 함수의 <code class="language-html highlighter-rouge">prototype</code>에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인합니다.</strong></p>

<p><code class="language-html highlighter-rouge">me instanceof Person</code>의 경우 <code class="language-html highlighter-rouge">me</code> 객체의 프로토타입 체인 상에 <code class="language-html highlighter-rouge">Person.prototype</code>에 바인딩된 객체가 존재하는지 확인합니다.<br />
<code class="language-html highlighter-rouge">me instanceof Object</code>의 경우도 마찬가지입니다.<br />
<code class="language-html highlighter-rouge">me</code> 객체의 프로토타입 체인 상에 <code class="language-html highlighter-rouge">Object.prototype</code>에 바인딩된 객체가 존재하는지 확인합니다.</p>

<p><code class="language-html highlighter-rouge">instanceof</code> 연산자를 함수로 표현하면 다음과 같습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">isInstanceof</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="kd">constructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 프로토타입 취득</span>
  <span class="kd">const</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">instance</span><span class="p">);</span>

  <span class="c1">// 재귀 탈출 조건</span>
  <span class="c1">// prototype이 null이면 프로토타입 체인의 종점에 다다른 것이다.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">prototype</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// 프로토타입이 생성자 함수의 prototype 프로퍼티에 바인딩된 객체라면 true를 반환한다.</span>
  <span class="c1">// 그렇지 않다면 재귀 호출로 프로토타입 체인 상의 상위 프로토타입으로 이동하여 확인한다.</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="nx">prototype</span> <span class="o">===</span> <span class="kd">constructor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">||</span> <span class="nx">isInstanceof</span><span class="p">(</span><span class="nx">prototype</span><span class="p">,</span> <span class="kd">constructor</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isInstanceof</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">Person</span><span class="p">));</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isInstanceof</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nb">Object</span><span class="p">));</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isInstanceof</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nb">Array</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 생성자 함수에 의해 프로토타입이 교체되어 <code class="language-html highlighter-rouge">consturctor</code> 프로퍼티와 생성자 함수 간의 연결이 파괴되어도 생성자 함수의 <code class="language-html highlighter-rouge">prototype</code> 프로퍼티와 프로토타입 간의 연결은 파괴되지 않으므로 <code class="language-html highlighter-rouge">instanceof</code>는 아무런 영향을 받지 않습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">Person</span><span class="p">;</span>
<span class="p">})();</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// constructor 프로퍼티와 생성자 함수 간의 연결은 파괴되어도 instanceof는 아무런 영향을 받지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// false</span>

<span class="c1">// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true</span>
<span class="c1">// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="11-직접-상속">11. 직접 상속</h2>

<h3 id="111-objectcreate에-의한-직접-상속">11.1 Object.create에 의한 직접 상속</h3>

<p><code class="language-html highlighter-rouge">Object.create</code> 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성합니다.<br />
<code class="language-html highlighter-rouge">Object.create</code> 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 <code class="language-html highlighter-rouge">OrdinaryObjectCreate</code>를 호출합니다.</p>

<p><code class="language-html highlighter-rouge">Object.create</code> 메서드의 첫 번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달합니다.<br />
두 번째 매개변수에는 생성할 객체의 프로퍼티 키와 디스크립터 객체로 이뤄진 객체를 전달합니다.<br />
이 객체의 형식은 <code class="language-html highlighter-rouge">Object.defineProperties</code> 메서드의 두 번째 인수와 동일합니다.<br />
두 번째 인수는 옵션이므로 생략 가능합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.</span>
<span class="c1">// obj → null</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// true</span>
<span class="c1">// Object.prototype을 상속받지 못한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// TypeError: obj.toString is not a function</span>

<span class="c1">// obj → Object.prototype → null</span>
<span class="c1">// obj = {};와 동일하다.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// obj → Object.prototype → null</span>
<span class="c1">// obj = { x: 1 };와 동일하다.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
<span class="p">});</span>
<span class="c1">// 위 코드는 다음과 동일하다.</span>
<span class="c1">// obj = Object.create(Object.prototype);</span>
<span class="c1">// obj.x = 1;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="kd">const</span> <span class="nx">myProto</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
<span class="c1">// 임의의 객체를 직접 상속받는다.</span>
<span class="c1">// obj → myProto → Object.prototype → null</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">myProto</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">myProto</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// obj → Person.prototype → Object.prototype → null</span>
<span class="c1">// obj = new Person('Lee')와 동일하다.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Lee</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>이처럼 <code class="language-html highlighter-rouge">Object.create</code> 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성합니다.<br />
즉, 객체를 생성하면서 직접적으로 상속을 구현하는 것입니다.</p>

<p>이 메서드의 장점은 다음과 같습니다.</p>

<ul>
  <li><code class="language-html highlighter-rouge">new</code> 연산자가 없이도 객체를 생성할 수 있습니다.</li>
  <li>프로토타입을 지정하면서 객체를 생성할 수 있습니다.</li>
  <li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있습니다.</li>
</ul>

<p><br /></p>

<p>참고로 <code class="language-html highlighter-rouge">Object.prototype</code>의 빌트인 메서드인 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code>, <code class="language-html highlighter-rouge">Object.prototype.isPrototypeOf</code>, <code class="language-html highlighter-rouge">Object.prototype.propertyIsEnumerable</code> 등은 모든 객체의 프로토타입 체인의 종점, 즉 Object.prototype의 메서드이므로 모든 객체가 상속받아 호출할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; true</span>
</code></pre></div></div>

<p><br /></p>

<p>그런데 ESLint에서는 앞의 예제와 같이 <code class="language-html highlighter-rouge">Object.prototype</code>의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않습니다.<br />
그 이유는 <code class="language-html highlighter-rouge">Object.create</code> 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문입니다.<br />
프로토타입 체인의 종점에 위치하는 객체는 <code class="language-html highlighter-rouge">Object.prototype</code>의 빌트인 메서드를 사용할 수 없습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// TypeError: obj.hasOwnProperty is not a function</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 이 같은 에러를 발생시킬 위험을 없애기 위해 <code class="language-html highlighter-rouge">Object.prototype</code>의 빌트인 메서드는 다음과 같이 간접적으로 호출하는 것이 좋습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 프로토타입이 null인 객체를 생성한다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function</span>

<span class="c1">// Object.prototype의 빌트인 메서드는 객체로 직접 호출하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="112-객체-리터럴-내부에서-__proto__에-의한-직접-상속">11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속</h3>

<p><code class="language-html highlighter-rouge">Object.create</code> 메서드에 의한 직접 상속은 앞에서 다룬 것과 같이 여러 장점이 있습니다.<br />
하지만 두 번째 인자로 프로퍼티를 정의하는 것은 번거롭습니다.<br />
일단 객체를 생성한 이후 프로퍼티를 추가하는 방법도 있으나 이 또한 깔끔한 방법은 아닙니다.</p>

<p>ES6에서는 객체 리터럴 내부에서 <code class="language-html highlighter-rouge">__proto__</code> 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">myProto</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>

<span class="c1">// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">y</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="c1">// 객체를 직접 상속받는다.</span>
  <span class="c1">// obj → myProto → Object.prototype → null</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="nx">myProto</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/* 위 코드는 아래와 동일하다.
const obj = Object.create(myProto, {
  y: { value: 20, writable: true, enumerable: true, configurable: true }
});
*/</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// 10 20</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">myProto</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="12-정적-프로퍼티메서드">12. 정적 프로퍼티/메서드</h2>

<p>정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말합니다.</p>

<p>다음 예제를 살펴봅시다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// 생성자 함수</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 프로토타입 메서드</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hi! My name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 정적 프로퍼티</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">staticProp</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">static prop</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 정적 메서드</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">staticMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">staticMethod</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">staticMethod</span><span class="p">();</span> <span class="c1">// staticMethod</span>

<span class="c1">// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</span>
<span class="c1">// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.</span>
<span class="nx">me</span><span class="p">.</span><span class="nx">staticMethod</span><span class="p">();</span> <span class="c1">// TypeError: me.staticMethod is not a function</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Person</code> 생성자 함수는 객체이므로 자신의 프로퍼티/메서드를 소유할 수 있습니다.<br />
<code class="language-html highlighter-rouge">Person</code> 생성자 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 합니다.<br />
정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없습니다.</p>

<p>생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메서드에 접근할 수 있습니다.<br />
하지만 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메서드가 아니므로 인스턴스로 접근할 수 없습니다.</p>

<p>앞에서 살펴본 <code class="language-html highlighter-rouge">Object.create</code> 메서드는 <code class="language-html highlighter-rouge">Object</code> 생성자 함수의 정적 메서드고 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드는 <code class="language-html highlighter-rouge">Object.prototype</code>의 메서드입니다.<br />
따라서 <code class="language-html highlighter-rouge">Object.create</code> 메서드는 인스턴스, 즉 <code class="language-html highlighter-rouge">Object</code> 생성자 함수가 생성한 객체로 호출할 수 없습니다.<br />
하지만 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드는 모든 객체의 프로토타입 체인의 종점, 즉 <code class="language-html highlighter-rouge">Object.prototype</code>의 메서드이므로 모든 객체가 호출할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Object.create는 정적 메서드다.</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span> <span class="p">});</span>

<span class="c1">// Object.prototype.hasOwnProperty는 프로토타입 메서드다.</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// -&gt; false</span>
</code></pre></div></div>

<p><br /></p>

<p>만약 인스턴스/프로토타입 메서드 내에서 <code class="language-html highlighter-rouge">this</code>를 사용하지 않는다면 그 메서드는 정적 메서드로 변경할 수 있습니다.<br />
인스턴스가 호출한 인스턴스/프로토타입 메서드 내에서 <code class="language-html highlighter-rouge">this</code>는 인스턴스를 가리킵니다.<br />
메서드 내에서 인스턴스를 참조할 필요가 없다면 정적 메서드로 변경하여도 동작합니다.<br />
프로토타입 메서드를 호출하려면 인스턴스를 생성해야 하지만 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">function</span> <span class="nx">Foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// 프로토타입 메서드</span>
<span class="c1">// this를 참조하지 않는 프로토타입 메소드는 정적 메서드로 변경해도 동일한 효과를 얻을 수 있다.</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="c1">// 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 한다.</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x</span>

<span class="c1">// 정적 메서드</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x</span>
</code></pre></div></div>

<p><br /></p>

<p>MDN과 같은 문서를 보면 다음과 같이 정적 프로퍼티/메서드와 프로토타입 프로퍼티/메서드를 구분하여 소개하고 있습니다.<br />
따라서 표기법만으로도 정적 프로퍼티/메서드와 프로토타입 프로퍼티/메서드를 구변할 수 있어야 합니다.</p>

<p>참고로 프로토타입 프로퍼티/메서드를 표기할 때 <code class="language-html highlighter-rouge">prototype</code>을 #으로 표기(예를 들어, <code class="language-html highlighter-rouge">Object.prototype.isPrototypeOf</code>를 <code class="language-html highlighter-rouge">Object#isPrototypeOf</code>으로 표기)하는 경우도 있으니 알아두도록 합시다.</p>

<p><br /><br /></p>

<h2 id="13-프로퍼티-존재-확인">13. 프로퍼티 존재 확인</h2>

<h3 id="131-in-연산자">13.1 in 연산자</h3>

<p><code class="language-html highlighter-rouge">in</code> 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// person 객체에 name 프로퍼티가 존재한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// true</span>
<span class="c1">// person 객체에 address 프로퍼티가 존재한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">address</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// true</span>
<span class="c1">// person 객체에 age 프로퍼티가 존재하지 않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">in</code> 연산자는 확인 대상 객체(위 예제의 경우 <code class="language-html highlighter-rouge">person</code> 객체)의 프로퍼티뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요합니다.<br />
<code class="language-html highlighter-rouge">person</code> 객체에는 <code class="language-html highlighter-rouge">toString</code>이라는 프로퍼티가 없지만 다음 코드의 실행 결과는 <code class="language-html highlighter-rouge">true</code>입니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">toString</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<p>이는 <code class="language-html highlighter-rouge">in</code> 연산자가 <code class="language-html highlighter-rouge">person</code> 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 <code class="language-html highlighter-rouge">toString</code> 프로퍼티를 검색했기 때문입니다.<br />
<code class="language-html highlighter-rouge">toString</code>은 <code class="language-html highlighter-rouge">Object.prototype</code>의 메서드입니다.</p>

<p><code class="language-html highlighter-rouge">in</code> 연산자 대신 ES6에서 도입된 <code class="language-html highlighter-rouge">Reflect.has</code> 메서드를 사용할 수도 있습니다.<br />
<code class="language-html highlighter-rouge">Reflect.has</code> 메서드는 <code class="language-html highlighter-rouge">in</code> 연산자와 동일하게 동작합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">toString</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="132-objectprototypehasownproperty-메서드">13.2 Object.prototype.hasOwnProperty 메서드</h3>

<p><code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드는 이름에서 알 수 있듯이 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">"</span><span class="s2">toString</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="14-프로퍼티-열거">14. 프로퍼티 열거</h2>

<h3 id="141-forin-문">14.1 for…in 문</h3>

<p>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 <code class="language-html highlighter-rouge">for...in</code> 문을 사용합니다.</p>

<p>for (변수선언문 in 객체) {…}</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">person</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">// name: Lee</span>
<span class="c1">// address: Seoul</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">for...in</code> 문은 객체의 프로퍼티 개수만큼 순회하며 <code class="language-html highlighter-rouge">for...in</code> 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당합니다.<br />
위 예제의 경우 <code class="language-html highlighter-rouge">person</code> 객체에는 2개의 프로퍼티가 있으므로 객체를 2번 순회하면서 프로퍼티 키를 <code class="language-html highlighter-rouge">key</code> 변수에 할당한 후 코드 블록을 실행합니다.<br />
첫 번째 순회에서는 프로퍼티 키 <code class="language-html highlighter-rouge">'name'</code>을 <code class="language-html highlighter-rouge">key</code> 변수에 할당한 후 코드 블록을 실행하고 두 번째 순회에서는 프로퍼티 키 <code class="language-html highlighter-rouge">'address'</code>를 <code class="language-html highlighter-rouge">key</code> 변수에 할당한 후 코드 블록을 실행합니다.</p>

<p><code class="language-html highlighter-rouge">for...in</code> 문은 <code class="language-html highlighter-rouge">in</code> 연산자처럼 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거합니다.<br />
하지만 위 예제의 경우 <code class="language-html highlighter-rouge">toString</code>과 같은 <code class="language-html highlighter-rouge">Object.prototype</code>의 프로퍼티가 열거되지 않습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// in 연산자는 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">toString</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// for...in 문도 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거한다.</span>
<span class="c1">// 하지만 toString과 같은 Object.prototype의 프로퍼티가 열거되지 않는다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">person</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// name: Lee</span>
<span class="c1">// address: Seoul</span>
</code></pre></div></div>

<p><br /></p>

<p>이는 <code class="language-html highlighter-rouge">toString</code> 메서드가 열거할 수 없도록 정의되어 있는 프로퍼티이기 때문입니다.<br />
다시 말해, <code class="language-html highlighter-rouge">Object.prototype.toString</code> 프로퍼티의 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 <code class="language-html highlighter-rouge">false</code>이기 때문입니다.<br />
프로퍼티 어트리뷰트 [[Enumerable]]은 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Object.getOwnPropertyDescriptor 메서드는 프로퍼티 디스크립터 객체를 반환한다.</span>
<span class="c1">// 프로퍼티 디스크립터 객체는 프로퍼티 어트리뷰트 정보를 담고 있는 객체다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="dl">"</span><span class="s2">toString</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// {value: ƒ, writable: true, enumerable: false, configurable: true}</span>
</code></pre></div></div>

<p><br /></p>

<p>따라서 <code class="language-html highlighter-rouge">for...in</code> 문에 대해 좀 더 정확히 표현하면 아래와 같습니다.</p>

<p><strong><code class="language-html highlighter-rouge">for...in</code> 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 <code class="language-html highlighter-rouge">true</code>인 프로퍼티를 순회하며 열거(enumeration)합니다.</strong></p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">person</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">// name: Lee</span>
<span class="c1">// address: Seoul</span>
<span class="c1">// age: 20</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-html highlighter-rouge">for...in</code> 문은 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">sym</span><span class="p">]:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">// a: 1</span>
</code></pre></div></div>

<p><br /></p>

<p>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만 열거하려면 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드를 사용하여 객체 자신의 프로퍼티인지 확인해야 합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 객체 자신의 프로퍼티인지 확인한다.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">person</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">person</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">// name: Lee</span>
<span class="c1">// address: Seoul</span>
</code></pre></div></div>

<p><br /></p>

<p>위 예제의 결과는 <code class="language-html highlighter-rouge">person</code> 객체의 프로퍼티가 정의된 순서대로 열거되었습니다.<br />
하지만 <code class="language-html highlighter-rouge">for...in</code> 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의하기 바랍니다.<br />
하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*
1: 1
2: 2
3: 3
b: b
a: a
*/</span>
</code></pre></div></div>

<p><br /></p>

<p>배열에는 <code class="language-html highlighter-rouge">for...in</code> 문을 사용하지 말고 일반적인 <code class="language-html highlighter-rouge">for</code> 문이나 <code class="language-html highlighter-rouge">for...of</code> 문 또는 <code class="language-html highlighter-rouge">Array.prototype.forEach</code> 메서드를 사용하기를 권장합니다.<br />
사실 배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 배열도 객체이므로 프로퍼티를 가질 수 있다.</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 프로퍼티 x도 출력된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// 1 2 3 10</span>
<span class="p">}</span>

<span class="c1">// arr.length는 3이다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// 1 2 3</span>
<span class="p">}</span>

<span class="c1">// forEach 메서드는 요소가 아닌 프로퍼티는 제외한다.</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="c1">// 1 2 3</span>

<span class="c1">// for...of는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1 2 3</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="142-objectkeysvaluesentries-메서드">14.2 Object.keys/values/entries 메서드</h3>

<p>지금까지 살펴보았듯이 <code class="language-html highlighter-rouge">for...in</code>문은 객체 자신의 고유 프로퍼티뿐 아니라 상속받은 프로퍼티도 열거합니다.<br />
따라서 <code class="language-html highlighter-rouge">Object.prototype.hasOwnProperty</code> 메서드를 사용하여 객체 자신의 프로퍼티인지 확인하는 추가 처리가 필요합니다.</p>

<p>객체 자신의 고유 프로퍼티만 열거하기 위해서는 <code class="language-html highlighter-rouge">for...in</code> 문을 사용하는 것보다 <code class="language-html highlighter-rouge">Object.keys/values/entries</code> 메서드를 사용하는 것을 권장합니다.</p>

<p><code class="language-html highlighter-rouge">Object.keys</code> 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">},</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">person</span><span class="p">));</span> <span class="c1">// ["name", "address"]</span>
</code></pre></div></div>

<p><br /></p>

<p>ES8에서 도입된 <code class="language-html highlighter-rouge">Object.values</code> 메서드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">person</span><span class="p">));</span> <span class="c1">// ["Lee", "Seoul"]</span>
</code></pre></div></div>

<p><br /></p>

<p>ES8에서 도입된 <code class="language-html highlighter-rouge">Object.entries</code> 메서드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환합니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">person</span><span class="p">));</span> <span class="c1">// [["name", "Lee"], ["address", "Seoul"]]</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">person</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">));</span>
<span class="cm">/*
name Lee
address Seoul
*/</span>
</code></pre></div></div>

<p><br /><br /><br /><br /><br /></p>
:ET